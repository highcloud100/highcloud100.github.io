<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Process &amp; Switch" /><meta name="author" content="highcloud" /><meta property="og:locale" content="ko" /><meta name="description" content="Process Process 하나의 작업 단위 program과 process program은 저장장치에 저장된 정적인 상태 process는 실행을 위해 메모리에 올라온 동적 상태 Program 실행과 Process 관리 program을 실행하면 process가 메모리에 올라온다. 이때 PCB ( 프로세스 제어 블록 ) 이 커널 영역에 올라온다. 커널은 PCB Data Structure 을 이용해 process를 관리한다. 커널은 하드웨어 정보 또한 Data Structure 로 관리한다. PCB나 하드웨어 자료구조를 메타데이터라 부른다. PCB PCB에는 무슨 정보가 있을까? 중요한 것들을 보자. 프로세스 구분자 : PID 메모리 정보 : 프로세스의 위치 정보 state vector save area : 각종 레지스터 정보 context change가 발생하면 자신의 상태를 저장해야 한다. PCB는 위와 같이 사용된다. Fork process를 복사하는 시스템 콜이다. 복제가 아닌 process를 만드는 것은 많은 자원이 소모된다. https://kldp.org/node/57233 https://www.bell-labs.com/usr/dmr/www/hist.html 장점 프로세스 생성 속도가 빠르다. 하드디스크에서 프로그램을 새로 가져오지 않고, 기존 메모리에서 복사하기 때문에 생성 속도가 빠르다. 추가 작업 없이 자원을 상속할 수 있다. 부모가 사용하던 모든 자원을 추가 작업 없이 자식에게 상속 가능하다. 시스템 관리를 효율적으로 할 수 있다. 부모와 자식 관계를 가지기 때문에 자식이 죽으면, 자식이 사용한 자원을 부모가 정리하게 된다. 단점 복사에 많은 비용이 든다. child process를 만들자 부모의 PCB 복사한다. 부모의 리소스를 자식과 공유한다. PID는 바뀐다. PPID, CPID가 바뀐다. 자식은 CPID = -1 child process의 메모리 공간을 확보한다. 메모리 관련 정보가 변한다. 디스크에서 이미지를 긁어온다. 기존 부모의 이미지에 overlay한 뒤, 시작 지점부터 실행된다. fork 코드의 이해 fork( )는 두 번 반환된다. ( ? ) 한번은 부모로, 한번은 자식으로 fork를 하면 프로세스가 복사되고, state vector가 복사되므로 자식 프로세스 또한 fork ( ) 반환부터 진행된다. 즉 자식 프로세스는 fork( ) 위의 코드를 진행하지 않는다. 두 번째 코드는 wait( ) 시스템 콜로 인해 자식이 먼저 실행된다. cpu를 뺏기고 큐에 다시 들어간다. Exec fork는 부모 프로세스를 복사하는 과정이다. 복사한 뒤 새로운 프로세스를 overlay 할 때 사용되는 시스템 콜이다. 즉 내용을 바꿔버리는 것이다. 이유 ? 프로세스의 구조체를 재활용하기 위함이다. 만약 새로운 프로세스를 만들려면 제어 블록을 만들고 메모리 확보 과정이 필요하다. 게다가 메모리 청소를 위해 부모, 자식 관계를 만들어야 한다. exec ( )은 복사한 뒤 코드 영역만 바꾼다. 동작 과정 기존 코드 영역을 지우고 새로운 코드로 바꾼다. 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 각종 레지스터 값과 사용한 파일 정보가 리셋된다. 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않는다. Wait 과 Exit wait wait는 자식 프로세스가 종료될 때까지 대기 상태에 빠진다 . 커널 모드로 갔다가 돌아오지 않고 cpu를 넘긴다. exit 프로세스가 종료된다. 이후 좀비 상태가 되고 부모에게 signal을 보내 회수되길 기다린다. system call summary fork create a child(copy) exec overlay new image, analogous to goto wait sleep until child is done exit frees all the resources, notify parent Context Switch 프로세스마다 할당된 cpu 사용 시간이 있고, 만약 시간을 다 쓴다면 cpu를 넘겨야 한다. 이때 Context Switch가 발생한다. 이때 PCB가 사용된다. PCB는 다음에 정리하도록 하자. 우선 사용자가 터미널을 킨다. shell이 만들어진다. “ls” 명령어 입력하면 fork가 발생한다. 복사된 child가 ready queue에 담긴다. wait으로 인해 부모는 cpu를 뺏긴다 . 자식은 exec을 실행하고 디스크에서 코드를 불러와 오버레이한다. ls 실행 후 exit 실행된다. 커널이 부모를 dispatches 하고, 실행된다. 커널 모드와 유저 모드의 흐름이다. 조금 더… 커널에서 프로세스를 관리할 때 pcb를 이용한다. wait 시스템 콜이 발생하면 context switch가 시작된다. 커널모드로 전환되고, 현재의 cpu state vector를 진행 중이었던 pcd에 저장을 한다. 이후 현 프로세스는 ready 상태로 바뀌고 cpu를 뺏긴다. ready queue에서 우선순위가 높은 프로세스를 찾아 실행한다. 이때 해당 프로세스의 pcb를 cpu에 로딩한다. 해당 프로세스의 주소로 PC가 이동한다. wait( ) 콜이 아닌 때에도 시스템 콜은 발생한다. 즉 내부적으로 context switch를 해주는 시스템 콜이 존재한다. schedule ( )이 그 역할을 한다. wait -&gt; schedule -&gt; context switch 정리 Context switch Process Context Demon 데몬은 백그라운드 프로세스이다. 메모리에 상주하며 대기타는 프로세스이다. 즉 루프를 돈다. init 프로세스가 실행하며 데몬 관련 프로그램 명령어는 d로 끝난다. 서비스라 부르기도 한다. 일부 리눅스 배포판에서는 init이 systemd로 대체된다. 이때 -d 는 데몬을 나타낸다. pstree 명령어를 치면 트리를 볼 수 있다. 모든 프로세스는 systemd에서 fork된다. 밑 사진은 우분투 20.04 기준이다. 쉘을 찾아보자. ssh를 이용해 원격 접속을 하고있다. 이때는 SSHD(Secure Shell Daemon)를 이용한다. ssh 연결을 받기 위해 대기 타는 것이다. pstree 실행 중임을 알 수 있다. 열심히 돌고 있는 mysql 데몬도 볼 수 있다." /><meta property="og:description" content="Process Process 하나의 작업 단위 program과 process program은 저장장치에 저장된 정적인 상태 process는 실행을 위해 메모리에 올라온 동적 상태 Program 실행과 Process 관리 program을 실행하면 process가 메모리에 올라온다. 이때 PCB ( 프로세스 제어 블록 ) 이 커널 영역에 올라온다. 커널은 PCB Data Structure 을 이용해 process를 관리한다. 커널은 하드웨어 정보 또한 Data Structure 로 관리한다. PCB나 하드웨어 자료구조를 메타데이터라 부른다. PCB PCB에는 무슨 정보가 있을까? 중요한 것들을 보자. 프로세스 구분자 : PID 메모리 정보 : 프로세스의 위치 정보 state vector save area : 각종 레지스터 정보 context change가 발생하면 자신의 상태를 저장해야 한다. PCB는 위와 같이 사용된다. Fork process를 복사하는 시스템 콜이다. 복제가 아닌 process를 만드는 것은 많은 자원이 소모된다. https://kldp.org/node/57233 https://www.bell-labs.com/usr/dmr/www/hist.html 장점 프로세스 생성 속도가 빠르다. 하드디스크에서 프로그램을 새로 가져오지 않고, 기존 메모리에서 복사하기 때문에 생성 속도가 빠르다. 추가 작업 없이 자원을 상속할 수 있다. 부모가 사용하던 모든 자원을 추가 작업 없이 자식에게 상속 가능하다. 시스템 관리를 효율적으로 할 수 있다. 부모와 자식 관계를 가지기 때문에 자식이 죽으면, 자식이 사용한 자원을 부모가 정리하게 된다. 단점 복사에 많은 비용이 든다. child process를 만들자 부모의 PCB 복사한다. 부모의 리소스를 자식과 공유한다. PID는 바뀐다. PPID, CPID가 바뀐다. 자식은 CPID = -1 child process의 메모리 공간을 확보한다. 메모리 관련 정보가 변한다. 디스크에서 이미지를 긁어온다. 기존 부모의 이미지에 overlay한 뒤, 시작 지점부터 실행된다. fork 코드의 이해 fork( )는 두 번 반환된다. ( ? ) 한번은 부모로, 한번은 자식으로 fork를 하면 프로세스가 복사되고, state vector가 복사되므로 자식 프로세스 또한 fork ( ) 반환부터 진행된다. 즉 자식 프로세스는 fork( ) 위의 코드를 진행하지 않는다. 두 번째 코드는 wait( ) 시스템 콜로 인해 자식이 먼저 실행된다. cpu를 뺏기고 큐에 다시 들어간다. Exec fork는 부모 프로세스를 복사하는 과정이다. 복사한 뒤 새로운 프로세스를 overlay 할 때 사용되는 시스템 콜이다. 즉 내용을 바꿔버리는 것이다. 이유 ? 프로세스의 구조체를 재활용하기 위함이다. 만약 새로운 프로세스를 만들려면 제어 블록을 만들고 메모리 확보 과정이 필요하다. 게다가 메모리 청소를 위해 부모, 자식 관계를 만들어야 한다. exec ( )은 복사한 뒤 코드 영역만 바꾼다. 동작 과정 기존 코드 영역을 지우고 새로운 코드로 바꾼다. 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 각종 레지스터 값과 사용한 파일 정보가 리셋된다. 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않는다. Wait 과 Exit wait wait는 자식 프로세스가 종료될 때까지 대기 상태에 빠진다 . 커널 모드로 갔다가 돌아오지 않고 cpu를 넘긴다. exit 프로세스가 종료된다. 이후 좀비 상태가 되고 부모에게 signal을 보내 회수되길 기다린다. system call summary fork create a child(copy) exec overlay new image, analogous to goto wait sleep until child is done exit frees all the resources, notify parent Context Switch 프로세스마다 할당된 cpu 사용 시간이 있고, 만약 시간을 다 쓴다면 cpu를 넘겨야 한다. 이때 Context Switch가 발생한다. 이때 PCB가 사용된다. PCB는 다음에 정리하도록 하자. 우선 사용자가 터미널을 킨다. shell이 만들어진다. “ls” 명령어 입력하면 fork가 발생한다. 복사된 child가 ready queue에 담긴다. wait으로 인해 부모는 cpu를 뺏긴다 . 자식은 exec을 실행하고 디스크에서 코드를 불러와 오버레이한다. ls 실행 후 exit 실행된다. 커널이 부모를 dispatches 하고, 실행된다. 커널 모드와 유저 모드의 흐름이다. 조금 더… 커널에서 프로세스를 관리할 때 pcb를 이용한다. wait 시스템 콜이 발생하면 context switch가 시작된다. 커널모드로 전환되고, 현재의 cpu state vector를 진행 중이었던 pcd에 저장을 한다. 이후 현 프로세스는 ready 상태로 바뀌고 cpu를 뺏긴다. ready queue에서 우선순위가 높은 프로세스를 찾아 실행한다. 이때 해당 프로세스의 pcb를 cpu에 로딩한다. 해당 프로세스의 주소로 PC가 이동한다. wait( ) 콜이 아닌 때에도 시스템 콜은 발생한다. 즉 내부적으로 context switch를 해주는 시스템 콜이 존재한다. schedule ( )이 그 역할을 한다. wait -&gt; schedule -&gt; context switch 정리 Context switch Process Context Demon 데몬은 백그라운드 프로세스이다. 메모리에 상주하며 대기타는 프로세스이다. 즉 루프를 돈다. init 프로세스가 실행하며 데몬 관련 프로그램 명령어는 d로 끝난다. 서비스라 부르기도 한다. 일부 리눅스 배포판에서는 init이 systemd로 대체된다. 이때 -d 는 데몬을 나타낸다. pstree 명령어를 치면 트리를 볼 수 있다. 모든 프로세스는 systemd에서 fork된다. 밑 사진은 우분투 20.04 기준이다. 쉘을 찾아보자. ssh를 이용해 원격 접속을 하고있다. 이때는 SSHD(Secure Shell Daemon)를 이용한다. ssh 연결을 받기 위해 대기 타는 것이다. pstree 실행 중임을 알 수 있다. 열심히 돌고 있는 mysql 데몬도 볼 수 있다." /><link rel="canonical" href="https://highcloud100.github.io/posts/process/" /><meta property="og:url" content="https://highcloud100.github.io/posts/process/" /><meta property="og:site_name" content="highcloud100" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-05T22:25:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Process &amp; Switch" /><meta name="twitter:site" content="@highcloud100" /><meta name="twitter:creator" content="@highcloud" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"highcloud"},"dateModified":"2022-07-05T22:25:00+09:00","datePublished":"2022-07-05T22:25:00+09:00","description":"Process Process 하나의 작업 단위 program과 process program은 저장장치에 저장된 정적인 상태 process는 실행을 위해 메모리에 올라온 동적 상태 Program 실행과 Process 관리 program을 실행하면 process가 메모리에 올라온다. 이때 PCB ( 프로세스 제어 블록 ) 이 커널 영역에 올라온다. 커널은 PCB Data Structure 을 이용해 process를 관리한다. 커널은 하드웨어 정보 또한 Data Structure 로 관리한다. PCB나 하드웨어 자료구조를 메타데이터라 부른다. PCB PCB에는 무슨 정보가 있을까? 중요한 것들을 보자. 프로세스 구분자 : PID 메모리 정보 : 프로세스의 위치 정보 state vector save area : 각종 레지스터 정보 context change가 발생하면 자신의 상태를 저장해야 한다. PCB는 위와 같이 사용된다. Fork process를 복사하는 시스템 콜이다. 복제가 아닌 process를 만드는 것은 많은 자원이 소모된다. https://kldp.org/node/57233 https://www.bell-labs.com/usr/dmr/www/hist.html 장점 프로세스 생성 속도가 빠르다. 하드디스크에서 프로그램을 새로 가져오지 않고, 기존 메모리에서 복사하기 때문에 생성 속도가 빠르다. 추가 작업 없이 자원을 상속할 수 있다. 부모가 사용하던 모든 자원을 추가 작업 없이 자식에게 상속 가능하다. 시스템 관리를 효율적으로 할 수 있다. 부모와 자식 관계를 가지기 때문에 자식이 죽으면, 자식이 사용한 자원을 부모가 정리하게 된다. 단점 복사에 많은 비용이 든다. child process를 만들자 부모의 PCB 복사한다. 부모의 리소스를 자식과 공유한다. PID는 바뀐다. PPID, CPID가 바뀐다. 자식은 CPID = -1 child process의 메모리 공간을 확보한다. 메모리 관련 정보가 변한다. 디스크에서 이미지를 긁어온다. 기존 부모의 이미지에 overlay한 뒤, 시작 지점부터 실행된다. fork 코드의 이해 fork( )는 두 번 반환된다. ( ? ) 한번은 부모로, 한번은 자식으로 fork를 하면 프로세스가 복사되고, state vector가 복사되므로 자식 프로세스 또한 fork ( ) 반환부터 진행된다. 즉 자식 프로세스는 fork( ) 위의 코드를 진행하지 않는다. 두 번째 코드는 wait( ) 시스템 콜로 인해 자식이 먼저 실행된다. cpu를 뺏기고 큐에 다시 들어간다. Exec fork는 부모 프로세스를 복사하는 과정이다. 복사한 뒤 새로운 프로세스를 overlay 할 때 사용되는 시스템 콜이다. 즉 내용을 바꿔버리는 것이다. 이유 ? 프로세스의 구조체를 재활용하기 위함이다. 만약 새로운 프로세스를 만들려면 제어 블록을 만들고 메모리 확보 과정이 필요하다. 게다가 메모리 청소를 위해 부모, 자식 관계를 만들어야 한다. exec ( )은 복사한 뒤 코드 영역만 바꾼다. 동작 과정 기존 코드 영역을 지우고 새로운 코드로 바꾼다. 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다. 각종 레지스터 값과 사용한 파일 정보가 리셋된다. 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않는다. Wait 과 Exit wait wait는 자식 프로세스가 종료될 때까지 대기 상태에 빠진다 . 커널 모드로 갔다가 돌아오지 않고 cpu를 넘긴다. exit 프로세스가 종료된다. 이후 좀비 상태가 되고 부모에게 signal을 보내 회수되길 기다린다. system call summary fork create a child(copy) exec overlay new image, analogous to goto wait sleep until child is done exit frees all the resources, notify parent Context Switch 프로세스마다 할당된 cpu 사용 시간이 있고, 만약 시간을 다 쓴다면 cpu를 넘겨야 한다. 이때 Context Switch가 발생한다. 이때 PCB가 사용된다. PCB는 다음에 정리하도록 하자. 우선 사용자가 터미널을 킨다. shell이 만들어진다. “ls” 명령어 입력하면 fork가 발생한다. 복사된 child가 ready queue에 담긴다. wait으로 인해 부모는 cpu를 뺏긴다 . 자식은 exec을 실행하고 디스크에서 코드를 불러와 오버레이한다. ls 실행 후 exit 실행된다. 커널이 부모를 dispatches 하고, 실행된다. 커널 모드와 유저 모드의 흐름이다. 조금 더… 커널에서 프로세스를 관리할 때 pcb를 이용한다. wait 시스템 콜이 발생하면 context switch가 시작된다. 커널모드로 전환되고, 현재의 cpu state vector를 진행 중이었던 pcd에 저장을 한다. 이후 현 프로세스는 ready 상태로 바뀌고 cpu를 뺏긴다. ready queue에서 우선순위가 높은 프로세스를 찾아 실행한다. 이때 해당 프로세스의 pcb를 cpu에 로딩한다. 해당 프로세스의 주소로 PC가 이동한다. wait( ) 콜이 아닌 때에도 시스템 콜은 발생한다. 즉 내부적으로 context switch를 해주는 시스템 콜이 존재한다. schedule ( )이 그 역할을 한다. wait -&gt; schedule -&gt; context switch 정리 Context switch Process Context Demon 데몬은 백그라운드 프로세스이다. 메모리에 상주하며 대기타는 프로세스이다. 즉 루프를 돈다. init 프로세스가 실행하며 데몬 관련 프로그램 명령어는 d로 끝난다. 서비스라 부르기도 한다. 일부 리눅스 배포판에서는 init이 systemd로 대체된다. 이때 -d 는 데몬을 나타낸다. pstree 명령어를 치면 트리를 볼 수 있다. 모든 프로세스는 systemd에서 fork된다. 밑 사진은 우분투 20.04 기준이다. 쉘을 찾아보자. ssh를 이용해 원격 접속을 하고있다. 이때는 SSHD(Secure Shell Daemon)를 이용한다. ssh 연결을 받기 위해 대기 타는 것이다. pstree 실행 중임을 알 수 있다. 열심히 돌고 있는 mysql 데몬도 볼 수 있다.","headline":"Process &amp; Switch","mainEntityOfPage":{"@type":"WebPage","@id":"https://highcloud100.github.io/posts/process/"},"url":"https://highcloud100.github.io/posts/process/"}</script><title>Process & Switch | highcloud100</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="highcloud100"><meta name="application-name" content="highcloud100"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/80192345?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">highcloud100</a></div><div class="site-subtitle font-italic">One of the comforting things about old memories is their tendency to take on a rosy glow.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/highcloud100" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/highcloud100" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['highcloud100','inha.edu'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Process & Switch</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Process & Switch</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1657027500" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 5, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> baekbumsung </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1723 words"> <em>9 min</em> read</span></div></div></div><div class="post-content"><h1 id="process">Process</h1><hr /><h2 id="process-1"><span class="mr-2">Process</span><a href="#process-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>하나의 작업 단위</ul><h3 id="program과-process"><span class="mr-2">program과 process</span><a href="#program과-process" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>program은 저장장치에 저장된 정적인 상태<li>process는 실행을 위해 메모리에 올라온 동적 상태</ul><h3 id="program-실행과-process-관리"><span class="mr-2">Program 실행과 Process 관리</span><a href="#program-실행과-process-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>program을 실행하면 process가 메모리에 올라온다.<li>이때 PCB ( 프로세스 제어 블록 ) 이 커널 영역에 올라온다.<ul><li>커널은 PCB Data Structure 을 이용해 process를 관리한다.</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/177484721-3bf43d4f-68fd-427b-a129-3ab97051ce65.png" alt="" data-proofer-ignore></p><ul><li>커널은 하드웨어 정보 또한 Data Structure 로 관리한다.</ul><blockquote><p>PCB나 하드웨어 자료구조를 메타데이터라 부른다.</p></blockquote><h3 id="pcb"><span class="mr-2">PCB</span><a href="#pcb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>PCB에는 무슨 정보가 있을까?</ul><p><img data-src="https://user-images.githubusercontent.com/80192345/177485281-bda315e2-9055-47cf-a111-9e81466faeb4.png" alt="" data-proofer-ignore><br /> 중요한 것들을 보자.</p><ol><li>프로세스 구분자 : PID<li>메모리 정보 : 프로세스의 위치 정보<li>state vector save area : 각종 레지스터 정보<ul><li>context change가 발생하면 자신의 상태를 저장해야 한다.</ul></ol><p><img data-src="https://user-images.githubusercontent.com/80192345/177486085-c9c411f6-1b93-4e97-8706-5318116d5dea.png" alt="" data-proofer-ignore></p><ul><li>PCB는 위와 같이 사용된다.</ul><h2 id="fork"><span class="mr-2">Fork</span><a href="#fork" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>process를 복사하는 시스템 콜이다.</p><ul><li>복제가 아닌 process를 만드는 것은 많은 자원이 소모된다.<li><a href="https://kldp.org/node/57233">https://kldp.org/node/57233</a><li><a href="https://www.bell-labs.com/usr/dmr/www/hist.html">https://www.bell-labs.com/usr/dmr/www/hist.html</a></ul><li><p>장점</p><ul><li>프로세스 생성 속도가 빠르다.<ul><li>하드디스크에서 프로그램을 새로 가져오지 않고, 기존 메모리에서 복사하기 때문에 생성 속도가 빠르다.</ul><li>추가 작업 없이 자원을 상속할 수 있다.<ul><li>부모가 사용하던 모든 자원을 추가 작업 없이 자식에게 상속 가능하다.</ul><li>시스템 관리를 효율적으로 할 수 있다.<ul><li>부모와 자식 관계를 가지기 때문에 자식이 죽으면, 자식이 사용한 자원을 부모가 정리하게 된다.</ul></ul><li><p>단점</p><ul><li>복사에 많은 비용이 든다.</ul></ul><h3 id="child-process를-만들자"><span class="mr-2">child process를 만들자</span><a href="#child-process를-만들자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ol><li>부모의 PCB 복사한다.<ul><li>부모의 리소스를 자식과 공유한다.<li>PID는 바뀐다.<li>PPID, CPID가 바뀐다.<ul><li>자식은 CPID = -1</ul></ul><li>child process의 메모리 공간을 확보한다.<ul><li>메모리 관련 정보가 변한다.</ul><li>디스크에서 이미지를 긁어온다.<ul><li>기존 부모의 이미지에 overlay한 뒤, 시작 지점부터 실행된다.</ul></ol><p><img data-src="https://user-images.githubusercontent.com/80192345/177528166-1f59636c-7455-4828-b05f-35dc16a24515.png" alt="" data-proofer-ignore><br /> <img data-src="https://user-images.githubusercontent.com/80192345/177528277-42fc2e04-a8fc-493c-955f-deb2a30f2a63.png" alt="" data-proofer-ignore><br /> <img data-src="https://user-images.githubusercontent.com/80192345/177528346-b11577ce-0759-4b26-9977-5fceeecc0b1d.png" alt="" data-proofer-ignore></p><h3 id="fork-코드의-이해"><span class="mr-2">fork 코드의 이해</span><a href="#fork-코드의-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>fork( )는 두 번 반환된다. ( ? )<ul><li>한번은 부모로, 한번은 자식으로</ul><li>fork를 하면 프로세스가 복사되고, state vector가 복사되므로 자식 프로세스 또한 fork ( ) 반환부터 진행된다.<ul><li>즉 자식 프로세스는 fork( ) 위의 코드를 진행하지 않는다.</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/177531246-e788fda8-394d-42c4-9990-c511f7bf9652.png" alt="" data-proofer-ignore><br /> <img data-src="https://user-images.githubusercontent.com/80192345/177531387-e4d81af1-7fe2-4b46-ae65-4f6956586f05.png" alt="" data-proofer-ignore></p><ul><li>두 번째 코드는 wait( ) 시스템 콜로 인해 자식이 먼저 실행된다.<ul><li>cpu를 뺏기고 큐에 다시 들어간다.</ul></ul><h2 id="exec"><span class="mr-2">Exec</span><a href="#exec" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>fork는 부모 프로세스를 복사하는 과정이다.<li>복사한 뒤 새로운 프로세스를 overlay 할 때 사용되는 시스템 콜이다.<ul><li>즉 내용을 바꿔버리는 것이다.</ul></ul><h3 id="이유-"><span class="mr-2">이유 ?</span><a href="#이유-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>프로세스의 구조체를 재활용하기 위함이다.<ul><li>만약 새로운 프로세스를 만들려면 제어 블록을 만들고 메모리 확보 과정이 필요하다. 게다가 메모리 청소를 위해 부모, 자식 관계를 만들어야 한다.<li>exec ( )은 복사한 뒤 코드 영역만 바꾼다.</ul></ul><h3 id="동작-과정"><span class="mr-2">동작 과정</span><a href="#동작-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>기존 코드 영역을 지우고 새로운 코드로 바꾼다.<li>데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋된다.<li>각종 레지스터 값과 사용한 파일 정보가 리셋된다.<ul><li>부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않는다.</ul></ul><h2 id="wait-과-exit"><span class="mr-2">Wait 과 Exit</span><a href="#wait-과-exit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="wait"><span class="mr-2">wait</span><a href="#wait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>wait는 자식 프로세스가 종료될 때까지 대기 상태에 빠진다 .<ul><li>커널 모드로 갔다가 돌아오지 않고 cpu를 넘긴다.</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/177537961-e9bb7ad9-c448-4edd-bbae-64ec36974b64.png" alt="" data-proofer-ignore></p><h3 id="exit"><span class="mr-2">exit</span><a href="#exit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>프로세스가 종료된다.<li>이후 좀비 상태가 되고 부모에게 signal을 보내 회수되길 기다린다.<br /> <img data-src="https://user-images.githubusercontent.com/80192345/177538287-91a3fa8c-b4d5-4b65-99ec-2fdbbcfd566c.png" alt="" data-proofer-ignore></ul><h3 id="system-call-summary"><span class="mr-2">system call summary</span><a href="#system-call-summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>fork<ul><li>create a child(copy)</ul><li>exec<ul><li>overlay new image, analogous to goto</ul><li>wait<ul><li>sleep until child is done</ul><li>exit<ul><li>frees all the resources, notify parent</ul></ul><h2 id="context-switch"><span class="mr-2">Context Switch</span><a href="#context-switch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>프로세스마다 할당된 cpu 사용 시간이 있고, 만약 시간을 다 쓴다면 cpu를 넘겨야 한다. 이때 Context Switch가 발생한다.</ul><blockquote><p>이때 PCB가 사용된다. PCB는 다음에 정리하도록 하자.</p></blockquote><p><img data-src="https://user-images.githubusercontent.com/80192345/177990225-a0e0ccf5-5965-4774-b464-fbc35d5b7c22.png" alt="" data-proofer-ignore></p><ol><li>우선 사용자가 터미널을 킨다.<li>shell이 만들어진다.<li>“ls” 명령어 입력하면 fork가 발생한다.<li>복사된 child가 ready queue에 담긴다.<li>wait으로 인해 부모는 cpu를 뺏긴다 .<li>자식은 exec을 실행하고 디스크에서 코드를 불러와 오버레이한다.<li>ls 실행 후 exit 실행된다.<li>커널이 부모를 dispatches 하고, 실행된다.</ol><p><img data-src="https://user-images.githubusercontent.com/80192345/177990917-e386417c-4765-463b-89e3-246c6f008182.png" alt="" data-proofer-ignore></p><ul><li>커널 모드와 유저 모드의 흐름이다.</ul><h3 id="조금-더..."><span class="mr-2">조금 더…</span><a href="#조금-더..." class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/177990838-1ce6ae1c-3312-4157-9d92-a21f2a796e01.png" alt="" data-proofer-ignore></p><blockquote><p>커널에서 프로세스를 관리할 때 pcb를 이용한다.</p></blockquote><ul><li>wait 시스템 콜이 발생하면 context switch가 시작된다.<li>커널모드로 전환되고, 현재의 cpu state vector를 진행 중이었던 pcd에 저장을 한다. 이후 현 프로세스는 ready 상태로 바뀌고 cpu를 뺏긴다.<li>ready queue에서 우선순위가 높은 프로세스를 찾아 실행한다.<ul><li>이때 해당 프로세스의 pcb를 cpu에 로딩한다.<li>해당 프로세스의 주소로 PC가 이동한다.</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/177997174-70d5658d-e11a-4866-88ff-83739be870e4.png" alt="" data-proofer-ignore></p><ul><li>wait( ) 콜이 아닌 때에도 시스템 콜은 발생한다.<li>즉 내부적으로 context switch를 해주는 시스템 콜이 존재한다.<li>schedule ( )이 그 역할을 한다.<ul><li>wait -&gt; schedule -&gt; context switch</ul></ul><h2 id="정리"><span class="mr-2">정리</span><a href="#정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="context-switch-1"><span class="mr-2">Context switch</span><a href="#context-switch-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/177998379-428030b8-e52c-4169-9357-f8e1ab566da5.png" alt="" data-proofer-ignore><br /> <img data-src="https://user-images.githubusercontent.com/80192345/177998474-981a098b-5a09-4fd7-8d48-c4eb04279ae0.png" alt="" data-proofer-ignore></p><h3 id="process-2"><span class="mr-2">Process</span><a href="#process-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/177998594-8071f9c2-172e-4860-b367-681596a3a8d3.png" alt="" data-proofer-ignore></p><h3 id="context"><span class="mr-2">Context</span><a href="#context" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/177998962-62ac6fe2-c0ef-4a47-8af5-fc6228d7b647.png" alt="" data-proofer-ignore></p><h3 id="demon"><span class="mr-2">Demon</span><a href="#demon" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/177999197-fb1b2a3a-b283-4207-bb9e-7256a7ac138b.png" alt="" data-proofer-ignore></p><ul><li><p>데몬은 백그라운드 프로세스이다.</p><li><p>메모리에 상주하며 대기타는 프로세스이다.</p><ul><li>즉 루프를 돈다.</ul><li><p>init 프로세스가 실행하며 데몬 관련 프로그램 명령어는 d로 끝난다.</p><ul><li>서비스라 부르기도 한다.</ul><li><p>일부 리눅스 배포판에서는 init이 systemd로 대체된다.</p><ul><li>이때 -d 는 데몬을 나타낸다.<li>pstree 명령어를 치면 트리를 볼 수 있다.<li>모든 프로세스는 systemd에서 fork된다.</ul></ul><blockquote><p>밑 사진은 우분투 20.04 기준이다.</p></blockquote><p><img data-src="https://user-images.githubusercontent.com/80192345/177999768-6819d0c7-9d9e-4d80-a600-420a75cdd9cc.png" alt="" data-proofer-ignore></p><ul><li><p>쉘을 찾아보자.</p><ul><li>ssh를 이용해 원격 접속을 하고있다.<li>이때는 SSHD(Secure Shell Daemon)를 이용한다.<li>ssh 연결을 받기 위해 대기 타는 것이다.</ul><li><p>pstree 실행 중임을 알 수 있다.<br /> <img data-src="https://user-images.githubusercontent.com/80192345/178000616-a7a71504-0e3a-41aa-b9ff-87ace4727960.png" alt="" data-proofer-ignore></p><li><p>열심히 돌고 있는 mysql 데몬도 볼 수 있다.<br /> <img data-src="https://user-images.githubusercontent.com/80192345/178000845-41bb6245-baa8-4ae9-8096-85aafe333d5f.png" alt="" data-proofer-ignore></p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/os/'>OS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a> <a href="/tags/cs/" class="post-tag no-text-decoration" >cs</a> <a href="/tags/summer/" class="post-tag no-text-decoration" >summer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Process+%26+Switch+-+highcloud100&url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fprocess%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Process+%26+Switch+-+highcloud100&u=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fprocess%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fprocess%2F&text=Process+%26+Switch+-+highcloud100" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script src="https://utteranc.es/client.js" repo="highcloud100/blog-utterances" issue-term="pathname" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/xv6%EB%B0%B1%EC%97%85/">xv6 백업</a><li><a href="/posts/gpuServerSetting/">gpu 서버 세팅</a><li><a href="/posts/winter/">2023 Winter Vacation</a><li><a href="/posts/%EB%85%B8%ED%8A%B8%EB%B6%81-%EC%84%B8%ED%8C%85/">노트북 세팅</a><li><a href="/posts/plan240508/">추후 계획과 현 상황?</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/start/"><div class="card-body"> <em class="small" data-ts="1656982800" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>운영체제 공부 정리</h3><div class="text-muted small"><p> 운영체제 공부 정리 2학년 여름 방학 운영체제에 대해 공부하려 한다. 7월 20일까지 공부 계획 중… 공부 자료 / 출처 OS쉽게 배우는 운영체제 조성호널널한 개발자 - 운영체제 강의Kernel of linux 고건 교수님실습과 그림으로 배우는 리눅스 구조</p></div></div></a></div><div class="card"> <a href="/posts/intro/"><div class="card-body"> <em class="small" data-ts="1656988740" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>intro of OS</h3><div class="text-muted small"><p> OS 운영체제는 사용자와 컴퓨터 사이에서 하드웨어 사이에서 작동하는 시스템이다. 운영체제의 목표는 다음과 같다. OS자원관리자원 보호하드웨어 인터페이스사용자 인터페이스효휼성안정성확장성편리성 Performance Throughput — jobs/sec Utilization — % of time busy Response time — sec / j...</p></div></div></a></div><div class="card"> <a href="/posts/systemcall/"><div class="card-body"> <em class="small" data-ts="1656999000" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>System Call</h3><div class="text-muted small"><p> SystemCall system call은 커널에게 I/O 작업을 요청하는 것이다. 하드웨어의 mode bit 를 사용하여 커널모드와 유저모드로 나눈다. cpu의 mode bit 가 0이면 kernel mode 이며, cpu는 어떤 메모리의 영역이든 접근할 수 있다. mode bit이 1이면 user mode로 cpu는 파일에 영향을 주는 명령...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/systemcall2/" class="btn btn-outline-primary" prompt="Older"><p>System Call with linux</p></a> <a href="/posts/introai/" class="btn btn-outline-primary" prompt="Newer"><p>intro of AI</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/highcloud100">baekbumsung</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script>
