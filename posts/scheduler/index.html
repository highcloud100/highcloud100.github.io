<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Schedule" /><meta name="author" content="highcloud" /><meta property="og:locale" content="ko" /><meta name="description" content="Process State Active status 프로세스의 상태를 정리해보자. 생성, 준비, 실행, 대기, 완료 -&gt; 5가지 상태 Ready cpu 스케줄러의 호출을 기다리는 상태 Running cpu를 사용하고 있는 상태 I/O 요청 시 cpu를 뺏김 -&gt; I/O까지 wait timeslice를 모두 소모하면 뺏김 Waiting blocking status 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 끝나면 인터럽트 발생 해당 프로세스 준비 상태로 이동 Zombie pcb만 남기고 다 지워짐 이후 부모에게 신호를 보낸다. ( 회수 요청 ) 부모 프로세스는 wait 시스템 콜을 통해 자식 프로세스의 종료 상태를 읽어 들인다. 부모가 os에게 자식이 종료되었는지 확인함 이후 완전히 pcb까지 소멸된다. 고아 프로세스 부모가 wait 대신 그냥 종료되버림 init을 부모로 삼는다. init은 주기적은 wait 요청으로 고아를 거둠 특별한 상태 휴식 상태 pause status 작업을 일시적으로 쉬고 있는 상태 보류 상태 suspend status 메모리에서 잠시 쫓겨난 상태 메모리가 꽉차서 밀려남 오류 발생 바이러스, 악의적 행동 매우 긴 주기 입출력 계속 지연 메모리 밖인 swap area에 보관됨 이후 보류 준비 상태를 지나 준비 상태로 이동한다. Process scheduler cpu 스케줄러는 프로세스의 모든 상태 변화를 조정한다. 목적은 찾아보자 스케줄링 단계 스케줄링은 3단계로 나뉜다. 고수준 스케줄링 저수준 스케줄링 중간 수준 스케줄링 High level scheduling 작업 스케줄링 ( job )이라고도 부른다. 전체 작업 수를 조절한다. 작업은 os의 가장 큰 일의 단위로 하나 혹은 여러 개의 프로세스로 이루어진다. 작업이 시작되면 자원이 소모되기에 기존 작업에 영향이 간다. 이에 작업을 승인할지 거부할지 결정한다. Admission scheduling 승인 스케줄링이라고도 부른다. 동시에 실행 가능한 프로세스의 총 개수가 정해진다. Middle level scheduling suspend와 active로 활성화된 프로세스 수를 조절한다. 일부 프로세스를 suspend 상태로 돌려 나머지가 원활하게 만든다. 고수준과 저수준 스케줄링 사이의 버퍼 역할 Low level scheduling cpu에 프로세스를 배당하는 작업을 한다. 빠르게 작동하여 short-term scheduling 이라도 부른다. Preemptive &amp; Non preemptive scheduling 선점형 스케줄링 운영체제가 강제로 cpu를 뺏을 수 있다. 비 선점형 스케줄링 운영체제가 강제로 뺏을 수 없다. Preemptive 선점형 스케줄링은 인터럽트처럼 cpu를 뺏을 수 있다. 문맥 교환 같은 낭비가 생긴다. 시분할 시스템에 사용된다. 사실상 대부분 Non preemptive 한 프로세스가 실행 상태에 들어가면 프로세스가 멈추지 않으면, cpu를 뺏을 수 없다. 스케줄링이나 문맥 교환의 오버헤드가 낮다. 다만 전체 시스템의 처리율이 떨어진다. 과거 일괄 작업 시스템에서 사용되었다. Priority 프로세스는 큐로 관리된다. 이때 우선순위와 그 척도가 필요하다. 기본적으로 커널 프로세스가 일반 프로세스보다 우선순위가 높다. 임의로 사용자가 지정할 수 있다. 전면 프로세스가 후면 프로세스보다 우선순위가 보통 높다. 입출력 집중 프로세스가 cpu 집중 프로세스보다 보통 높다. 입출력 집중 프로세스는 cpu를 잠깐 쓰고 넘기기 때문이다. Queue cpu 사용하는 프로세스들 pcb를 연결한 큐가 있다. 이때 우선순위에 따라 여러 큐를 만들어 multiple queue로 관리된다. 모두 검색하는 오버헤드를 줄임 이때 bitmap 배열을 이용해서 해당 우선순위의 큐가 pcb(task)를 가지고 있는지 확인한다. 만약 1이라면 해당 큐를 순회하며 cpu를 할당한다. 프로세스가 time slice를 모두 소모하면 expired array로 넘어간다. 해당 우선순위에 맞게 active array가 사용이 다 되면 expired 에 time slice를 배정하고 active array로 바꾼다. 대기 상태의 프로세스들 위에서 설명한 큐는 실행 상태를 다룬다. 대기 상태의 프로세스도 큐를 가지고 있다. 대기 상태 다단계 큐는 같은 입출력 장치끼리 모아 놓는다. 입출력이 동시에 끝나면 여러 인터럽트가 한번에 처리된다. 이를 위해 인터럽트 벡터를 사용하며 입출력이 완료된 pcb 들은 준비 상태로 이동한다. 정리 Scheduling algorithm 스케줄링 알고리즘을 알아보자. 종류" /><meta property="og:description" content="Process State Active status 프로세스의 상태를 정리해보자. 생성, 준비, 실행, 대기, 완료 -&gt; 5가지 상태 Ready cpu 스케줄러의 호출을 기다리는 상태 Running cpu를 사용하고 있는 상태 I/O 요청 시 cpu를 뺏김 -&gt; I/O까지 wait timeslice를 모두 소모하면 뺏김 Waiting blocking status 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 끝나면 인터럽트 발생 해당 프로세스 준비 상태로 이동 Zombie pcb만 남기고 다 지워짐 이후 부모에게 신호를 보낸다. ( 회수 요청 ) 부모 프로세스는 wait 시스템 콜을 통해 자식 프로세스의 종료 상태를 읽어 들인다. 부모가 os에게 자식이 종료되었는지 확인함 이후 완전히 pcb까지 소멸된다. 고아 프로세스 부모가 wait 대신 그냥 종료되버림 init을 부모로 삼는다. init은 주기적은 wait 요청으로 고아를 거둠 특별한 상태 휴식 상태 pause status 작업을 일시적으로 쉬고 있는 상태 보류 상태 suspend status 메모리에서 잠시 쫓겨난 상태 메모리가 꽉차서 밀려남 오류 발생 바이러스, 악의적 행동 매우 긴 주기 입출력 계속 지연 메모리 밖인 swap area에 보관됨 이후 보류 준비 상태를 지나 준비 상태로 이동한다. Process scheduler cpu 스케줄러는 프로세스의 모든 상태 변화를 조정한다. 목적은 찾아보자 스케줄링 단계 스케줄링은 3단계로 나뉜다. 고수준 스케줄링 저수준 스케줄링 중간 수준 스케줄링 High level scheduling 작업 스케줄링 ( job )이라고도 부른다. 전체 작업 수를 조절한다. 작업은 os의 가장 큰 일의 단위로 하나 혹은 여러 개의 프로세스로 이루어진다. 작업이 시작되면 자원이 소모되기에 기존 작업에 영향이 간다. 이에 작업을 승인할지 거부할지 결정한다. Admission scheduling 승인 스케줄링이라고도 부른다. 동시에 실행 가능한 프로세스의 총 개수가 정해진다. Middle level scheduling suspend와 active로 활성화된 프로세스 수를 조절한다. 일부 프로세스를 suspend 상태로 돌려 나머지가 원활하게 만든다. 고수준과 저수준 스케줄링 사이의 버퍼 역할 Low level scheduling cpu에 프로세스를 배당하는 작업을 한다. 빠르게 작동하여 short-term scheduling 이라도 부른다. Preemptive &amp; Non preemptive scheduling 선점형 스케줄링 운영체제가 강제로 cpu를 뺏을 수 있다. 비 선점형 스케줄링 운영체제가 강제로 뺏을 수 없다. Preemptive 선점형 스케줄링은 인터럽트처럼 cpu를 뺏을 수 있다. 문맥 교환 같은 낭비가 생긴다. 시분할 시스템에 사용된다. 사실상 대부분 Non preemptive 한 프로세스가 실행 상태에 들어가면 프로세스가 멈추지 않으면, cpu를 뺏을 수 없다. 스케줄링이나 문맥 교환의 오버헤드가 낮다. 다만 전체 시스템의 처리율이 떨어진다. 과거 일괄 작업 시스템에서 사용되었다. Priority 프로세스는 큐로 관리된다. 이때 우선순위와 그 척도가 필요하다. 기본적으로 커널 프로세스가 일반 프로세스보다 우선순위가 높다. 임의로 사용자가 지정할 수 있다. 전면 프로세스가 후면 프로세스보다 우선순위가 보통 높다. 입출력 집중 프로세스가 cpu 집중 프로세스보다 보통 높다. 입출력 집중 프로세스는 cpu를 잠깐 쓰고 넘기기 때문이다. Queue cpu 사용하는 프로세스들 pcb를 연결한 큐가 있다. 이때 우선순위에 따라 여러 큐를 만들어 multiple queue로 관리된다. 모두 검색하는 오버헤드를 줄임 이때 bitmap 배열을 이용해서 해당 우선순위의 큐가 pcb(task)를 가지고 있는지 확인한다. 만약 1이라면 해당 큐를 순회하며 cpu를 할당한다. 프로세스가 time slice를 모두 소모하면 expired array로 넘어간다. 해당 우선순위에 맞게 active array가 사용이 다 되면 expired 에 time slice를 배정하고 active array로 바꾼다. 대기 상태의 프로세스들 위에서 설명한 큐는 실행 상태를 다룬다. 대기 상태의 프로세스도 큐를 가지고 있다. 대기 상태 다단계 큐는 같은 입출력 장치끼리 모아 놓는다. 입출력이 동시에 끝나면 여러 인터럽트가 한번에 처리된다. 이를 위해 인터럽트 벡터를 사용하며 입출력이 완료된 pcb 들은 준비 상태로 이동한다. 정리 Scheduling algorithm 스케줄링 알고리즘을 알아보자. 종류" /><link rel="canonical" href="https://highcloud100.github.io/posts/scheduler/" /><meta property="og:url" content="https://highcloud100.github.io/posts/scheduler/" /><meta property="og:site_name" content="highcloud100" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-15T13:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Schedule" /><meta name="twitter:site" content="@highcloud100" /><meta name="twitter:creator" content="@highcloud" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"highcloud"},"dateModified":"2022-07-16T14:49:57+09:00","datePublished":"2022-07-15T13:00:00+09:00","description":"Process State Active status 프로세스의 상태를 정리해보자. 생성, 준비, 실행, 대기, 완료 -&gt; 5가지 상태 Ready cpu 스케줄러의 호출을 기다리는 상태 Running cpu를 사용하고 있는 상태 I/O 요청 시 cpu를 뺏김 -&gt; I/O까지 wait timeslice를 모두 소모하면 뺏김 Waiting blocking status 입출력이 완료될 때까지 기다리는 상태이다. 입출력이 끝나면 인터럽트 발생 해당 프로세스 준비 상태로 이동 Zombie pcb만 남기고 다 지워짐 이후 부모에게 신호를 보낸다. ( 회수 요청 ) 부모 프로세스는 wait 시스템 콜을 통해 자식 프로세스의 종료 상태를 읽어 들인다. 부모가 os에게 자식이 종료되었는지 확인함 이후 완전히 pcb까지 소멸된다. 고아 프로세스 부모가 wait 대신 그냥 종료되버림 init을 부모로 삼는다. init은 주기적은 wait 요청으로 고아를 거둠 특별한 상태 휴식 상태 pause status 작업을 일시적으로 쉬고 있는 상태 보류 상태 suspend status 메모리에서 잠시 쫓겨난 상태 메모리가 꽉차서 밀려남 오류 발생 바이러스, 악의적 행동 매우 긴 주기 입출력 계속 지연 메모리 밖인 swap area에 보관됨 이후 보류 준비 상태를 지나 준비 상태로 이동한다. Process scheduler cpu 스케줄러는 프로세스의 모든 상태 변화를 조정한다. 목적은 찾아보자 스케줄링 단계 스케줄링은 3단계로 나뉜다. 고수준 스케줄링 저수준 스케줄링 중간 수준 스케줄링 High level scheduling 작업 스케줄링 ( job )이라고도 부른다. 전체 작업 수를 조절한다. 작업은 os의 가장 큰 일의 단위로 하나 혹은 여러 개의 프로세스로 이루어진다. 작업이 시작되면 자원이 소모되기에 기존 작업에 영향이 간다. 이에 작업을 승인할지 거부할지 결정한다. Admission scheduling 승인 스케줄링이라고도 부른다. 동시에 실행 가능한 프로세스의 총 개수가 정해진다. Middle level scheduling suspend와 active로 활성화된 프로세스 수를 조절한다. 일부 프로세스를 suspend 상태로 돌려 나머지가 원활하게 만든다. 고수준과 저수준 스케줄링 사이의 버퍼 역할 Low level scheduling cpu에 프로세스를 배당하는 작업을 한다. 빠르게 작동하여 short-term scheduling 이라도 부른다. Preemptive &amp; Non preemptive scheduling 선점형 스케줄링 운영체제가 강제로 cpu를 뺏을 수 있다. 비 선점형 스케줄링 운영체제가 강제로 뺏을 수 없다. Preemptive 선점형 스케줄링은 인터럽트처럼 cpu를 뺏을 수 있다. 문맥 교환 같은 낭비가 생긴다. 시분할 시스템에 사용된다. 사실상 대부분 Non preemptive 한 프로세스가 실행 상태에 들어가면 프로세스가 멈추지 않으면, cpu를 뺏을 수 없다. 스케줄링이나 문맥 교환의 오버헤드가 낮다. 다만 전체 시스템의 처리율이 떨어진다. 과거 일괄 작업 시스템에서 사용되었다. Priority 프로세스는 큐로 관리된다. 이때 우선순위와 그 척도가 필요하다. 기본적으로 커널 프로세스가 일반 프로세스보다 우선순위가 높다. 임의로 사용자가 지정할 수 있다. 전면 프로세스가 후면 프로세스보다 우선순위가 보통 높다. 입출력 집중 프로세스가 cpu 집중 프로세스보다 보통 높다. 입출력 집중 프로세스는 cpu를 잠깐 쓰고 넘기기 때문이다. Queue cpu 사용하는 프로세스들 pcb를 연결한 큐가 있다. 이때 우선순위에 따라 여러 큐를 만들어 multiple queue로 관리된다. 모두 검색하는 오버헤드를 줄임 이때 bitmap 배열을 이용해서 해당 우선순위의 큐가 pcb(task)를 가지고 있는지 확인한다. 만약 1이라면 해당 큐를 순회하며 cpu를 할당한다. 프로세스가 time slice를 모두 소모하면 expired array로 넘어간다. 해당 우선순위에 맞게 active array가 사용이 다 되면 expired 에 time slice를 배정하고 active array로 바꾼다. 대기 상태의 프로세스들 위에서 설명한 큐는 실행 상태를 다룬다. 대기 상태의 프로세스도 큐를 가지고 있다. 대기 상태 다단계 큐는 같은 입출력 장치끼리 모아 놓는다. 입출력이 동시에 끝나면 여러 인터럽트가 한번에 처리된다. 이를 위해 인터럽트 벡터를 사용하며 입출력이 완료된 pcb 들은 준비 상태로 이동한다. 정리 Scheduling algorithm 스케줄링 알고리즘을 알아보자. 종류","headline":"Schedule","mainEntityOfPage":{"@type":"WebPage","@id":"https://highcloud100.github.io/posts/scheduler/"},"url":"https://highcloud100.github.io/posts/scheduler/"}</script><title>Schedule | highcloud100</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="highcloud100"><meta name="application-name" content="highcloud100"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/80192345?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">highcloud100</a></div><div class="site-subtitle font-italic">One of the comforting things about old memories is their tendency to take on a rosy glow.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/highcloud100" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/highcloud100" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['highcloud100','inha.edu'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Schedule</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Schedule</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1657857600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 15, 2022 </em> </span> <span> Updated <em class="" data-ts="1657950597" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 16, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> baekbumsung </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2839 words"> <em>15 min</em> read</span></div></div></div><div class="post-content"><h1 id="process-state">Process State</h1><hr /><h2 id="active-status"><span class="mr-2">Active status</span><a href="#active-status" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>프로세스의 상태를 정리해보자.<li>생성, 준비, 실행, 대기, 완료 -&gt; 5가지 상태</ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178965720-fce90c6f-d281-40e0-85ff-cb2589d47b86.png" alt="" data-proofer-ignore></p><ul><li><p>Ready</p><ul><li>cpu 스케줄러의 호출을 기다리는 상태</ul><li><p>Running</p><ul><li>cpu를 사용하고 있는 상태<li>I/O 요청 시 cpu를 뺏김 -&gt; I/O까지 wait<li>timeslice를 모두 소모하면 뺏김</ul><li><p>Waiting</p><ul><li>blocking status<li>입출력이 완료될 때까지 기다리는 상태이다.<li>입출력이 끝나면 인터럽트 발생<ul><li>해당 프로세스 준비 상태로 이동</ul></ul><li><p>Zombie</p><ul><li>pcb만 남기고 다 지워짐<li>이후 부모에게 신호를 보낸다. ( 회수 요청 )<li>부모 프로세스는 wait 시스템 콜을 통해 자식 프로세스의 종료 상태를 읽어 들인다.<ul><li>부모가 os에게 자식이 종료되었는지 확인함<li>이후 완전히 pcb까지 소멸된다.</ul></ul></ul><blockquote><p>고아 프로세스<br /> 부모가 wait 대신 그냥 종료되버림<br /> init을 부모로 삼는다. init은 주기적은 wait 요청으로 고아를 거둠<br /> <img data-src="https://user-images.githubusercontent.com/80192345/178975180-03dab8ae-9efe-48f8-ab38-81130019fb05.png" alt="" data-proofer-ignore></p></blockquote><h2 id="특별한-상태"><span class="mr-2">특별한 상태</span><a href="#특별한-상태" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="휴식-상태"><span class="mr-2">휴식 상태</span><a href="#휴식-상태" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>pause status<li>작업을 일시적으로 쉬고 있는 상태</ul><h3 id="보류-상태"><span class="mr-2">보류 상태</span><a href="#보류-상태" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>suspend status<li>메모리에서 잠시 쫓겨난 상태<ul><li>메모리가 꽉차서 밀려남<li>오류 발생<li>바이러스, 악의적 행동<li>매우 긴 주기<li>입출력 계속 지연</ul><li>메모리 밖인 swap area에 보관됨<li>이후 보류 준비 상태를 지나 준비 상태로 이동한다.</ul><h1 id="process-scheduler">Process scheduler</h1><hr /><ul><li>cpu 스케줄러는 프로세스의 모든 상태 변화를 조정한다.<li><a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">목적은 찾아보자</a></ul><h2 id="스케줄링-단계"><span class="mr-2">스케줄링 단계</span><a href="#스케줄링-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>스케줄링은 3단계로 나뉜다.<ol><li>고수준 스케줄링<li>저수준 스케줄링<li>중간 수준 스케줄링</ol></ul><h3 id="high-level-scheduling"><span class="mr-2">High level scheduling</span><a href="#high-level-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>작업 스케줄링 ( job )이라고도 부른다. 전체 작업 수를 조절한다.<li>작업은 os의 가장 큰 일의 단위로 하나 혹은 여러 개의 프로세스로 이루어진다.<li>작업이 시작되면 자원이 소모되기에 기존 작업에 영향이 간다.<ul><li>이에 작업을 승인할지 거부할지 결정한다.<li>Admission scheduling 승인 스케줄링이라고도 부른다.</ul><li>동시에 실행 가능한 프로세스의 총 개수가 정해진다.</ul><h3 id="middle-level-scheduling"><span class="mr-2">Middle level scheduling</span><a href="#middle-level-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>suspend와 active로 활성화된 프로세스 수를 조절한다.<ul><li>일부 프로세스를 suspend 상태로 돌려 나머지가 원활하게 만든다.</ul><li>고수준과 저수준 스케줄링 사이의 버퍼 역할</ul><h3 id="low-level-scheduling"><span class="mr-2">Low level scheduling</span><a href="#low-level-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>cpu에 프로세스를 배당하는 작업을 한다.<li>빠르게 작동하여 short-term scheduling 이라도 부른다.</ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178981275-a167f4d8-c476-4cb7-b3ba-d99093cada4e.png" alt="" data-proofer-ignore></p><h2 id="preemptive--non-preemptive-scheduling"><span class="mr-2">Preemptive &amp; Non preemptive scheduling</span><a href="#preemptive--non-preemptive-scheduling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>선점형 스케줄링<ul><li>운영체제가 강제로 cpu를 뺏을 수 있다.</ul><li>비 선점형 스케줄링<ul><li>운영체제가 강제로 뺏을 수 없다.</ul></ul><h3 id="preemptive"><span class="mr-2">Preemptive</span><a href="#preemptive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>선점형 스케줄링은 인터럽트처럼 cpu를 뺏을 수 있다.<ul><li>문맥 교환 같은 낭비가 생긴다.<li>시분할 시스템에 사용된다.<ul><li>사실상 대부분</ul></ul></ul><h3 id="non-preemptive"><span class="mr-2">Non preemptive</span><a href="#non-preemptive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>한 프로세스가 실행 상태에 들어가면 프로세스가 멈추지 않으면, cpu를 뺏을 수 없다.<li>스케줄링이나 문맥 교환의 오버헤드가 낮다.<li>다만 전체 시스템의 처리율이 떨어진다.<ul><li>과거 일괄 작업 시스템에서 사용되었다.</ul></ul><h2 id="priority"><span class="mr-2">Priority</span><a href="#priority" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>프로세스는 큐로 관리된다.<li>이때 우선순위와 그 척도가 필요하다.<ul><li>기본적으로 커널 프로세스가 일반 프로세스보다 우선순위가 높다.<li>임의로 사용자가 지정할 수 있다.<li>전면 프로세스가 후면 프로세스보다 우선순위가 보통 높다.<li>입출력 집중 프로세스가 cpu 집중 프로세스보다 보통 높다.<ul><li>입출력 집중 프로세스는 cpu를 잠깐 쓰고 넘기기 때문이다.</ul></ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178984246-483e0470-2ea8-47c0-83d7-c8abd478a4c9.png" alt="" data-proofer-ignore></p><h2 id="queue"><span class="mr-2">Queue</span><a href="#queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="cpu-사용하는-프로세스들"><span class="mr-2">cpu 사용하는 프로세스들</span><a href="#cpu-사용하는-프로세스들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/80192345/178993511-5dac8a56-d654-40c9-8bc4-e56433faba42.png" alt="" data-proofer-ignore></p><ul><li>pcb를 연결한 큐가 있다.<li>이때 우선순위에 따라 여러 큐를 만들어 multiple queue로 관리된다.<ul><li>모두 검색하는 오버헤드를 줄임</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178993901-703b5262-ade6-4bc1-92ad-0f38f44010f3.png" alt="" data-proofer-ignore></p><ul><li>이때 bitmap 배열을 이용해서 해당 우선순위의 큐가 pcb(task)를 가지고 있는지 확인한다.<ul><li>만약 1이라면 해당 큐를 순회하며 cpu를 할당한다.</ul></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178994332-fd15d188-1ea6-4dcf-b445-6848f4d88cab.png" alt="" data-proofer-ignore></p><ul><li>프로세스가 time slice를 모두 소모하면 expired array로 넘어간다.<ul><li>해당 우선순위에 맞게</ul><li>active array가 사용이 다 되면 expired 에 time slice를 배정하고 active array로 바꾼다.</ul><p><img data-src="https://user-images.githubusercontent.com/80192345/178995050-19ba2c1f-fe25-49a9-a444-92ad8d77f50f.png" alt="" data-proofer-ignore></p><h3 id="대기-상태의-프로세스들"><span class="mr-2">대기 상태의 프로세스들</span><a href="#대기-상태의-프로세스들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>위에서 설명한 큐는 실행 상태를 다룬다.</p><ul><li>대기 상태의 프로세스도 큐를 가지고 있다.</ul><li><p>대기 상태 다단계 큐는 같은 입출력 장치끼리 모아 놓는다.</p><ul><li>입출력이 동시에 끝나면 여러 인터럽트가 한번에 처리된다.<li>이를 위해 인터럽트 벡터를 사용하며 입출력이 완료된 pcb 들은 준비 상태로 이동한다.</ul></ul><h3 id="정리"><span class="mr-2">정리</span><a href="#정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/80192345/178999987-7ff0e5f9-df36-4a66-a1ea-9ae432e72b2c.png" alt="" data-proofer-ignore></p><h1 id="scheduling-algorithm">Scheduling algorithm</h1><hr /><ul><li>스케줄링 알고리즘을 알아보자.</ul><h2 id="종류"><span class="mr-2">종류</span><a href="#종류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><div class="table-wrapper"><table><thead><tr><th>구분<th>종류<tbody><tr><td>비선점형<td>FCFS, SJF, HRN<tr><td>선점형<td>라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐<tr><td>둘 다 가능<td>우선순위 스케줄링</table></div><h2 id="성능-기준"><span class="mr-2">성능 기준</span><a href="#성능-기준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/179002876-985da6e5-b438-4975-afd6-a0fa85b45167.png" alt="" data-proofer-ignore></p><ul><li>대기 시간 : 프로세스 생성 후 실행까지 걸린 시간<li>응답 시간 : 첫 작업을 시작한 후 첫 번째 반응까지 걸린 시간<li>실행 시간 : 프로세스 작업이 시작된 후 종료되기까지 시간<li>반환 시간 : 대기 시간을 포함하여 실행이 종료될 때까지의 시간</ul><h3 id="기준"><span class="mr-2">기준</span><a href="#기준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>보통 스케줄링 알고리즘 성능 비교에는 평균 대기 시간을 사용한다.<ul><li>모든 프로세스들이 실행되기까지 걸린 대기 시간의 평균<li>다만 순서나 작업 패턴에 따라 역전되기도 한다.</ul></ul><h2 id="fcfs"><span class="mr-2">FCFS</span><a href="#fcfs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>비선점형 방식<li>first come first served<li>선입선출 스케줄링<ul><li>큐가 하나라 모든 프로세스는 우선순위가 동일하다.</ul><li>즉 하나씩 순서대로 실행된다.<ul><li>일괄 작업 시스템</ul></ul><h3 id="단점"><span class="mr-2">단점</span><a href="#단점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>convoy effect<li>입출력 요청시 cpu가 놀게됨</ul><h2 id="sjf"><span class="mr-2">SJF</span><a href="#sjf" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>비선점형 방식<li>shortest job first<ul><li>shortest process first, 최단 프로세스 우선 스케줄링</ul><li>실행 시간이 가장 짧은 작업부터 cpu를 할당<li>convoy 효과를 완화함</ul><h3 id="단점-1"><span class="mr-2">단점</span><a href="#단점-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>운영체제가 프로세스의 종료 시간을 정확히 예측하기 어렵다.<ul><li>즉 프로세스의 작업 길이를 알아야 스케줄을 하는데 길이를 모른다.<ul><li>현대 프로세스는 사용자와의 상호작용이 빈번하기 때문이다.</ul><li>고로 적용하기 어렵다.</ul><li>공평하지 않다.<ul><li>starvation<li>infinite blocking<li>이를 완화하기 위한 방법으로 aging이 있으나 기준 선정의 한계가 있다.</ul></ol><h2 id="hrn"><span class="mr-2">HRN</span><a href="#hrn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>비선점형<li>highest response ratio next<li>SJF의 아사 현상을 해결하기 위한 알고리즘이다.<ul><li>HRN은 서비스를 받기 위해 기다린 시간과 cpu 사용 시간을 고려하여 스케줄링한다.<li>즉 대기 시간을 고려해 아사를 완화한다.<li>스케줄링에 에이징을 구현한 것</ul></ul><p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>우선순위</mtext><mo>=</mo><mfrac><mtext>대기&nbsp;시간&nbsp;+&nbsp;CPU&nbsp;사용&nbsp;시간&nbsp;</mtext><mtext>CPU&nbsp;사용시간&nbsp;</mtext></mfrac></mrow><annotation encoding="application/x-tex"> \text{우선순위} ={ \text{대기 시간 + CPU 사용 시간 } \over \text{CPU 사용시간 }} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord text"><span class="mord hangul_fallback">우선순위</span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.04633em; vertical-align: -0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.36033em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord">CPU&nbsp;</span><span class="mord hangul_fallback">사용시간</span><span class="mord">&nbsp;</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord text"><span class="mord hangul_fallback">대기</span><span class="mord">&nbsp;</span><span class="mord hangul_fallback">시간</span><span class="mord">&nbsp;+&nbsp;CPU&nbsp;</span><span class="mord hangul_fallback">사용</span><span class="mord">&nbsp;</span><span class="mord hangul_fallback">시간</span><span class="mord">&nbsp;</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></span></p><h3 id="단점-2"><span class="mr-2">단점</span><a href="#단점-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>여전히 공평성이 위배되어 많이 사용되지 않는다.</ul><h2 id="rr"><span class="mr-2">RR</span><a href="#rr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>선점형 알고리즘 중 가장 단순하고 대표적인 방식<li>round robin<li>한 프로세스가 할당 받은 시간 동안만 작업하고 큐의 맨 뒤로 보내지는 알고리즘<ul><li>완료 될 때까지 계속 순환</ul><li>FCFS와 차이점은 time slice가 있다는 것이다.<ul><li>이는 convoy 효과를 완화한다.</ul></ul><h3 id="유의점"><span class="mr-2">유의점</span><a href="#유의점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>문맥 교환에 대한 오버헤드를 생각해야 한다.<ul><li>이에 타임 슬라이스의 크기가 중요하다.</ul><li>타임 슬라이스가 너무 크면 FCFS와 다르지 않다.<li>타임 슬라이스가 너무 작으면 문맥 교환 오버헤드가 커진다.</ul><h2 id="srt"><span class="mr-2">SRT</span><a href="#srt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>shortest remaining time<ul><li>최소 잔류 시간 우선 스케줄링</ul><li>SJF와 RR을 혼합한 방법<li>기본적으로 RR 이다.<ul><li>다만 작업 시간이 가장 적은 프로세스를 선택하여 cpu를 할당한다.</ul></ul><h3 id="단점-3"><span class="mr-2">단점</span><a href="#단점-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>실행중인 프로세스와 큐의 프로세스들의 시간을 주기적으로 계산해야한다.<li>문맥 교환 오버헤드<li>프로세스의 종료 시간 예측 어려움, 아사 현상<li>잘 안쓰임</ul><h2 id="priority-1"><span class="mr-2">Priority</span><a href="#priority-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>중요도를 기준으로 우선 순위를 반영해 스케줄링한다.</ul><h3 id="단점-4"><span class="mr-2">단점</span><a href="#단점-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>공평성 위배와 아사 현상</ul><h2 id="mlq"><span class="mr-2">MLQ</span><a href="#mlq" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><p><img data-src="https://user-images.githubusercontent.com/80192345/179135646-c6c31001-fb09-46f4-9f1b-c03fd220f580.png" alt="" data-proofer-ignore></p><ul><li><p>MultiLevel Queue Scheduling 다단계 큐 스케줄링</p><li><p>우선 순위에 따라 준비 큐를 여러 개 사용하는 방식</p><li><p>고정형 우선순위를 사용한다.</p><ul><li>프로세스가 시간을 소모하면 원래 큐로 돌아간다.<li>상단의 큐의 모든 프로세스의 작업이 끝나야 다음 큐의 작업이 실행된다.<li>선점형 방식으로 우선순위가 높은 프로세스가 먼저 작동한다.<ul><li>만약 하위 큐의 프로세스 진행 중 상위 단계 큐에 프로세스가 도착하면 뺏어버림</ul></ul><li><p>각각의 큐에 대한 다른 스케줄링 알고리즘 적용가능하다.</p><li><p>큐의 우선순위에 따라 타임 슬라이스를 조절할 수 있다.</p></ul><h3 id="단점-5"><span class="mr-2">단점</span><a href="#단점-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>우선 순위가 높은 큐가 완료되어야 다음 큐가 실행된다.<ul><li>기아 현상</ul></ul><h2 id="mfq"><span class="mr-2">MFQ</span><a href="#mfq" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>multilevel feedback queue<li>우선순위가 낮은 프로세스들의 문제를 보완한 방식<li>cpu를 사용한 프로세스는 우선순위가 한 단계 낮아진다.<ul><li>즉 다음 단계 큐로 들어간다.</ul><li>우선순위에 따라 큐의 타임 슬라이스가 다르다.<ul><li>낮은 순위는 cpu를 얻을 확률이 상대적으로 낮다.<li>그래서 오래 사용하도록 타임 슬라이스를 크게 만들어준다.<li>마지막 큐의 타임 슬라이스는 무한대의 타임 슬라이스를 가지며 이는 FCFS 로 동작하는 것과 같다.</ul><li>MFQ는 오늘날의 운영체제가 사용하는 방식이다. 변동 우선순위 알고리즘의 전형적인 예이다.</ul><blockquote><p>물론 커널 프로세스는 일반 프로세스의 큐로 삽입되지 않는다.</p></blockquote><h2 id="룰"><span class="mr-2">룰</span><a href="#룰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>짧은 작업에 우선권이 있다.<li>입출력 관련 프로세스에 우선권을 준다.</ul><p><img data-src="https://user-images.githubusercontent.com/80192345/179147936-08e42e2e-8d61-40ad-9e2a-1b9883327f99.png" alt="" data-proofer-ignore></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/os/'>OS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a> <a href="/tags/cs/" class="post-tag no-text-decoration" >cs</a> <a href="/tags/summer/" class="post-tag no-text-decoration" >summer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Schedule+-+highcloud100&url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fscheduler%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Schedule+-+highcloud100&u=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fscheduler%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fscheduler%2F&text=Schedule+-+highcloud100" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script src="https://utteranc.es/client.js" repo="highcloud100/blog-utterances" issue-term="pathname" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/xv6%EB%B0%B1%EC%97%85/">xv6 백업</a><li><a href="/posts/gpuServerSetting/">gpu 서버 세팅</a><li><a href="/posts/winter/">2023 Winter Vacation</a><li><a href="/posts/%EB%85%B8%ED%8A%B8%EB%B6%81-%EC%84%B8%ED%8C%85/">노트북 세팅</a><li><a href="/posts/plan240508/">추후 계획과 현 상황?</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/start/"><div class="card-body"> <em class="small" data-ts="1656982800" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>운영체제 공부 정리</h3><div class="text-muted small"><p> 운영체제 공부 정리 2학년 여름 방학 운영체제에 대해 공부하려 한다. 7월 20일까지 공부 계획 중… 공부 자료 / 출처 OS쉽게 배우는 운영체제 조성호널널한 개발자 - 운영체제 강의Kernel of linux 고건 교수님실습과 그림으로 배우는 리눅스 구조</p></div></div></a></div><div class="card"> <a href="/posts/intro/"><div class="card-body"> <em class="small" data-ts="1656988740" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>intro of OS</h3><div class="text-muted small"><p> OS 운영체제는 사용자와 컴퓨터 사이에서 하드웨어 사이에서 작동하는 시스템이다. 운영체제의 목표는 다음과 같다. OS자원관리자원 보호하드웨어 인터페이스사용자 인터페이스효휼성안정성확장성편리성 Performance Throughput — jobs/sec Utilization — % of time busy Response time — sec / j...</p></div></div></a></div><div class="card"> <a href="/posts/systemcall/"><div class="card-body"> <em class="small" data-ts="1656999000" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>System Call</h3><div class="text-muted small"><p> SystemCall system call은 커널에게 I/O 작업을 요청하는 것이다. 하드웨어의 mode bit 를 사용하여 커널모드와 유저모드로 나눈다. cpu의 mode bit 가 0이면 kernel mode 이며, cpu는 어떤 메모리의 영역이든 접근할 수 있다. mode bit이 1이면 user mode로 cpu는 파일에 영향을 주는 명령...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/optimization/" class="btn btn-outline-primary" prompt="Older"><p>Optimization</p></a> <a href="/posts/concu/" class="btn btn-outline-primary" prompt="Newer"><p>Process synchronization</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/highcloud100">baekbumsung</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script>
