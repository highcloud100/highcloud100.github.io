<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Physical memory management" /><meta name="author" content="highcloud" /><meta property="og:locale" content="ko" /><meta name="description" content="메모리 관리의 개요 시작 이전에는 하나의 프로그램만 실행시켜서 메모리 관리에 어려움이 크지 않았다. 현재 시분할 시스템에서는 많은 프로세스들이 메모리에 올라와 실행된다. 이를 효휼적으로 관리할 방법이 필요하다. MMU memory manage unit 하드웨어이다. 간단히 정리한다. 역할 가져오기 프로세스와 데이터를 메모리로 가져온다. 요청이 없어도 필요할 것 같은 데이터를 미리 가져온다. 배치 작업 가져온 프로세스와 데이터를 메모리에 적절히 배치한다. 재배치 작업 메모리가 가득 찬 상황이면 일부 프로세스를 하드로 옮기는 작업을 한다. 정책 가져오기 정책 프로세스의 필요한 데이터를 언제 가져올지 결정하는 정책 prefetch 를 하기도 한다. 배치 정책 paging : 메모리를 같은 크기로 자르는 것 segmentation : 프로세스 크기에 맞게 자르는 것 이런 기술을 이용해 효율적인 메모리 관리 정책을 만든다. 재배치 정책 replacement algorithm : 무슨 프로세스를 내보낼지 정한다. 메모리 주소 32bit / 64bit cpu 메모리는 1byte마다 주소를 붙여 사용한다. 이때 MAR(메모리 주소 레지스터)를 이용한다. 32bit는 MAR의 크기가 32비트이다. 64bit는 64비트 여기서 cpu가 관리할 수 있는 메모리 공간의 사이즈를 알 수 있다. 32bit : 2^32 byte = 4GB 정도 64bit : 2^64 byte = 겁내 많음 즉 32bit에 16GB RAM을 박는 것은 … 메모리 주소는 다음과 같이 나눌 수 있다. Physical address space : 하드웨어 관점 logical address space : 사용자 입장 절대 주소와 상대 주소 메모리 영역 기본적으로 메모리는 운영체제 영역과 사용자 영역으로 나뉜다. 이때 사용자 영역이 운영체제 영역을 침범하지 못하도록 cpu의 경계 레지스터 값을 이용해 검사하고 막는다. 문제점은 운영체제의 크기가 변한다면 사용자 프로그램의 주소가 변해야 한다. 즉 프로그램을 짤 때는 360번지부터 400번지를 사용해서 프로그래밍하면, 후에 os가 바뀌면 문제가 발생한다. 이렇게 직접 물리주소를 이용하는 것은 문제가 많다. 절대 주소와 상대 주소 메모리 관리자 입장에서는 실제 메모리의 주소를 사용한다. 절대 주소는 실제 물리 주소를 가르킨다. 하지만 사용자 프로세스 입장에서는 0번부터 생각한다. 즉 운영체제와 mmu가 알아서 관리한다. 이때 재배치 레지스터를 이용한다. 이를 논리 주소 공간이라 부른다. 단일 프로그래밍과 메모리 할당 메모리 오버레이 컴퓨터의 메인 메모리보다 큰 프로그램을 실행하도록 만드는 방법 적당한 크기로 잘라서 메모리에 가져온다. module 단위로 나눈다. 프로그램의 일부만 올라와서 실행된다. 스왑 module 단위로 나누어졌을 때 사용하지 않는 module은 어디에 보관될까? 저장장치의 swap area에 보관된다. ( 공간을 마련함 ) swap in : 스왑 영역에서 메모리로 데이터를 가져옴 swap out : 메모리에서 스왑 영역으로 데이터를 내보냄 이는 메모리 관리자가 관리한다. 이때 사용자는 스왑 영역과 메모리 영역의 크기를 합쳐서 인식하게 된다. 사진에서 사용자는 5GB 프로그램을 돌리는 것으로 인식한다. 다중 프로그래밍과 메모리 지금까지는 한 프로세스만 실행되는 상황을 다루었다. 지금부터는 여러 프로세스들이 실행될 때 메모리 관리를 살펴보겠다. 메모리 분할 방식 메모리 배치 정책에 해당된다. 여러 프로세스를 메모리에 어떻게 배치할 것인가? variable-size partitioning : 가변 분할 방식 fixed-size partitioning : 고정 분할 방식 variable-size partitioning 프로세스의 크기에 맞게 메모리가 분할 된다. 즉 메모리의 영역 크기가 모두 다르다. 한 프로세스가 연속된 공간에 배치된다. contiguous memory allocation 장점 프로세스를 한 덩어리로 처리해서 연속적인 공간에 배치 가능 단점 메모리 관리가 복잡하다. fixed-size partitioning 프로세스의 크기 상관없이 메모리가 같은 크기로 분할 된다. 비연속 메모리 할당이라 부른다. noncontiguous memory allocation 장점 메모리 관리가 편하다. 단점 작은 프로세스가 올라오면 메모리 낭비가 발생한다. 혹은 잘려서 Variable-size partitioning 외부 단편화 만약 B와 D가 종료되고 E라는 프로그램이 메모리에 올라오는 상황을 생각해보자 빈 공간보다 큰 공간을 필요로 하는 E는 올라가지 못한다. 결국 E는 공간을 받을 수 있을 때까지 기다린다 ( 아사 ) 결국 작은 빈 공간이 생기게 된다. 이 현상을 Fragmentation(단편화)이라 부른다. 빈 공간을 external fragmentation이라 부른다. hole 프로세스 밖에서 빈 공간(조각)이 발생하기 때문이다. 이를 해결하기 위해 memory placement strategy : 메모리 배치 방식 조각이 발생하지 않도록 배치 defragmentation : 조각 모음 조각을 모아서 크게 만듬 메모리 배치 방식 대표적인 방법은 다음과 같다. (버디 시스템도 있다.) 최초 배치 적재 가능한 공간을 순서대로 탐색하다가 첫 번째 공간에 넣음 빈 공간 전체 탐색이 필요 없다. 다만 단편화가 잘 발생한다. 최적 배치 빈 공간을 모두 확인하고 가장 작은 공간에 배치한다. 아주 작은 조각이 남게 된다. 최악 배치 빈 공간을 모두 확인하고 가장 큰 공간에 배치한다. 남은 조각도 커서 재활용이 가능하다. 다만 시간이 지나면 작은 조각이 남는다. 조각 모음 아무리 배치를 잘해도 단편화 현상이 발생한다. 사용하지 못하는 작은 조각들을 모아 쓸모 있게 만들 필요가 있다. 단계 프로세스들 중단 적당한 위치로 차곡차곡 옮긴다. ( 상대 주소 값 ) 프로세스 다시 시작 많은 시간이 걸린다. Fixed-size partitioning 가상 메모리에서는 고정 분할 방식을 paging이라 부른다. 메모리를 같은 크기로 나누어 관리는 쉽지만 프로세스가 나눠 저장된다. 내부 단편화 기본적으로 가변 분할 방식보다는 고정 분할 방식을 기본으로 사용한다. 이는 관리가 수월하기 때문이다. 프로그램을 일정 단위로 나누기 때문에 외부 단편화는 발생하지 않는다. 일정 단위를 페이지라 부른다. ( 가상 메모리 기준 ) 하지만 단위보다 작은 공간을 필요로 하면 내부 단편화가 발생한다. internal fragmentation 이를 해결하는 방법은 없다. 조각 모음이나 남는 공간을 다른 프로세스에게 넘길 수 없다. 유일한 해결책은 단위의 크기를 조절하는 것이다." /><meta property="og:description" content="메모리 관리의 개요 시작 이전에는 하나의 프로그램만 실행시켜서 메모리 관리에 어려움이 크지 않았다. 현재 시분할 시스템에서는 많은 프로세스들이 메모리에 올라와 실행된다. 이를 효휼적으로 관리할 방법이 필요하다. MMU memory manage unit 하드웨어이다. 간단히 정리한다. 역할 가져오기 프로세스와 데이터를 메모리로 가져온다. 요청이 없어도 필요할 것 같은 데이터를 미리 가져온다. 배치 작업 가져온 프로세스와 데이터를 메모리에 적절히 배치한다. 재배치 작업 메모리가 가득 찬 상황이면 일부 프로세스를 하드로 옮기는 작업을 한다. 정책 가져오기 정책 프로세스의 필요한 데이터를 언제 가져올지 결정하는 정책 prefetch 를 하기도 한다. 배치 정책 paging : 메모리를 같은 크기로 자르는 것 segmentation : 프로세스 크기에 맞게 자르는 것 이런 기술을 이용해 효율적인 메모리 관리 정책을 만든다. 재배치 정책 replacement algorithm : 무슨 프로세스를 내보낼지 정한다. 메모리 주소 32bit / 64bit cpu 메모리는 1byte마다 주소를 붙여 사용한다. 이때 MAR(메모리 주소 레지스터)를 이용한다. 32bit는 MAR의 크기가 32비트이다. 64bit는 64비트 여기서 cpu가 관리할 수 있는 메모리 공간의 사이즈를 알 수 있다. 32bit : 2^32 byte = 4GB 정도 64bit : 2^64 byte = 겁내 많음 즉 32bit에 16GB RAM을 박는 것은 … 메모리 주소는 다음과 같이 나눌 수 있다. Physical address space : 하드웨어 관점 logical address space : 사용자 입장 절대 주소와 상대 주소 메모리 영역 기본적으로 메모리는 운영체제 영역과 사용자 영역으로 나뉜다. 이때 사용자 영역이 운영체제 영역을 침범하지 못하도록 cpu의 경계 레지스터 값을 이용해 검사하고 막는다. 문제점은 운영체제의 크기가 변한다면 사용자 프로그램의 주소가 변해야 한다. 즉 프로그램을 짤 때는 360번지부터 400번지를 사용해서 프로그래밍하면, 후에 os가 바뀌면 문제가 발생한다. 이렇게 직접 물리주소를 이용하는 것은 문제가 많다. 절대 주소와 상대 주소 메모리 관리자 입장에서는 실제 메모리의 주소를 사용한다. 절대 주소는 실제 물리 주소를 가르킨다. 하지만 사용자 프로세스 입장에서는 0번부터 생각한다. 즉 운영체제와 mmu가 알아서 관리한다. 이때 재배치 레지스터를 이용한다. 이를 논리 주소 공간이라 부른다. 단일 프로그래밍과 메모리 할당 메모리 오버레이 컴퓨터의 메인 메모리보다 큰 프로그램을 실행하도록 만드는 방법 적당한 크기로 잘라서 메모리에 가져온다. module 단위로 나눈다. 프로그램의 일부만 올라와서 실행된다. 스왑 module 단위로 나누어졌을 때 사용하지 않는 module은 어디에 보관될까? 저장장치의 swap area에 보관된다. ( 공간을 마련함 ) swap in : 스왑 영역에서 메모리로 데이터를 가져옴 swap out : 메모리에서 스왑 영역으로 데이터를 내보냄 이는 메모리 관리자가 관리한다. 이때 사용자는 스왑 영역과 메모리 영역의 크기를 합쳐서 인식하게 된다. 사진에서 사용자는 5GB 프로그램을 돌리는 것으로 인식한다. 다중 프로그래밍과 메모리 지금까지는 한 프로세스만 실행되는 상황을 다루었다. 지금부터는 여러 프로세스들이 실행될 때 메모리 관리를 살펴보겠다. 메모리 분할 방식 메모리 배치 정책에 해당된다. 여러 프로세스를 메모리에 어떻게 배치할 것인가? variable-size partitioning : 가변 분할 방식 fixed-size partitioning : 고정 분할 방식 variable-size partitioning 프로세스의 크기에 맞게 메모리가 분할 된다. 즉 메모리의 영역 크기가 모두 다르다. 한 프로세스가 연속된 공간에 배치된다. contiguous memory allocation 장점 프로세스를 한 덩어리로 처리해서 연속적인 공간에 배치 가능 단점 메모리 관리가 복잡하다. fixed-size partitioning 프로세스의 크기 상관없이 메모리가 같은 크기로 분할 된다. 비연속 메모리 할당이라 부른다. noncontiguous memory allocation 장점 메모리 관리가 편하다. 단점 작은 프로세스가 올라오면 메모리 낭비가 발생한다. 혹은 잘려서 Variable-size partitioning 외부 단편화 만약 B와 D가 종료되고 E라는 프로그램이 메모리에 올라오는 상황을 생각해보자 빈 공간보다 큰 공간을 필요로 하는 E는 올라가지 못한다. 결국 E는 공간을 받을 수 있을 때까지 기다린다 ( 아사 ) 결국 작은 빈 공간이 생기게 된다. 이 현상을 Fragmentation(단편화)이라 부른다. 빈 공간을 external fragmentation이라 부른다. hole 프로세스 밖에서 빈 공간(조각)이 발생하기 때문이다. 이를 해결하기 위해 memory placement strategy : 메모리 배치 방식 조각이 발생하지 않도록 배치 defragmentation : 조각 모음 조각을 모아서 크게 만듬 메모리 배치 방식 대표적인 방법은 다음과 같다. (버디 시스템도 있다.) 최초 배치 적재 가능한 공간을 순서대로 탐색하다가 첫 번째 공간에 넣음 빈 공간 전체 탐색이 필요 없다. 다만 단편화가 잘 발생한다. 최적 배치 빈 공간을 모두 확인하고 가장 작은 공간에 배치한다. 아주 작은 조각이 남게 된다. 최악 배치 빈 공간을 모두 확인하고 가장 큰 공간에 배치한다. 남은 조각도 커서 재활용이 가능하다. 다만 시간이 지나면 작은 조각이 남는다. 조각 모음 아무리 배치를 잘해도 단편화 현상이 발생한다. 사용하지 못하는 작은 조각들을 모아 쓸모 있게 만들 필요가 있다. 단계 프로세스들 중단 적당한 위치로 차곡차곡 옮긴다. ( 상대 주소 값 ) 프로세스 다시 시작 많은 시간이 걸린다. Fixed-size partitioning 가상 메모리에서는 고정 분할 방식을 paging이라 부른다. 메모리를 같은 크기로 나누어 관리는 쉽지만 프로세스가 나눠 저장된다. 내부 단편화 기본적으로 가변 분할 방식보다는 고정 분할 방식을 기본으로 사용한다. 이는 관리가 수월하기 때문이다. 프로그램을 일정 단위로 나누기 때문에 외부 단편화는 발생하지 않는다. 일정 단위를 페이지라 부른다. ( 가상 메모리 기준 ) 하지만 단위보다 작은 공간을 필요로 하면 내부 단편화가 발생한다. internal fragmentation 이를 해결하는 방법은 없다. 조각 모음이나 남는 공간을 다른 프로세스에게 넘길 수 없다. 유일한 해결책은 단위의 크기를 조절하는 것이다." /><link rel="canonical" href="https://highcloud100.github.io/posts/memory/" /><meta property="og:url" content="https://highcloud100.github.io/posts/memory/" /><meta property="og:site_name" content="highcloud100" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-19T22:30:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Physical memory management" /><meta name="twitter:site" content="@highcloud100" /><meta name="twitter:creator" content="@highcloud" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"highcloud"},"dateModified":"2022-07-19T22:30:00+09:00","datePublished":"2022-07-19T22:30:00+09:00","description":"메모리 관리의 개요 시작 이전에는 하나의 프로그램만 실행시켜서 메모리 관리에 어려움이 크지 않았다. 현재 시분할 시스템에서는 많은 프로세스들이 메모리에 올라와 실행된다. 이를 효휼적으로 관리할 방법이 필요하다. MMU memory manage unit 하드웨어이다. 간단히 정리한다. 역할 가져오기 프로세스와 데이터를 메모리로 가져온다. 요청이 없어도 필요할 것 같은 데이터를 미리 가져온다. 배치 작업 가져온 프로세스와 데이터를 메모리에 적절히 배치한다. 재배치 작업 메모리가 가득 찬 상황이면 일부 프로세스를 하드로 옮기는 작업을 한다. 정책 가져오기 정책 프로세스의 필요한 데이터를 언제 가져올지 결정하는 정책 prefetch 를 하기도 한다. 배치 정책 paging : 메모리를 같은 크기로 자르는 것 segmentation : 프로세스 크기에 맞게 자르는 것 이런 기술을 이용해 효율적인 메모리 관리 정책을 만든다. 재배치 정책 replacement algorithm : 무슨 프로세스를 내보낼지 정한다. 메모리 주소 32bit / 64bit cpu 메모리는 1byte마다 주소를 붙여 사용한다. 이때 MAR(메모리 주소 레지스터)를 이용한다. 32bit는 MAR의 크기가 32비트이다. 64bit는 64비트 여기서 cpu가 관리할 수 있는 메모리 공간의 사이즈를 알 수 있다. 32bit : 2^32 byte = 4GB 정도 64bit : 2^64 byte = 겁내 많음 즉 32bit에 16GB RAM을 박는 것은 … 메모리 주소는 다음과 같이 나눌 수 있다. Physical address space : 하드웨어 관점 logical address space : 사용자 입장 절대 주소와 상대 주소 메모리 영역 기본적으로 메모리는 운영체제 영역과 사용자 영역으로 나뉜다. 이때 사용자 영역이 운영체제 영역을 침범하지 못하도록 cpu의 경계 레지스터 값을 이용해 검사하고 막는다. 문제점은 운영체제의 크기가 변한다면 사용자 프로그램의 주소가 변해야 한다. 즉 프로그램을 짤 때는 360번지부터 400번지를 사용해서 프로그래밍하면, 후에 os가 바뀌면 문제가 발생한다. 이렇게 직접 물리주소를 이용하는 것은 문제가 많다. 절대 주소와 상대 주소 메모리 관리자 입장에서는 실제 메모리의 주소를 사용한다. 절대 주소는 실제 물리 주소를 가르킨다. 하지만 사용자 프로세스 입장에서는 0번부터 생각한다. 즉 운영체제와 mmu가 알아서 관리한다. 이때 재배치 레지스터를 이용한다. 이를 논리 주소 공간이라 부른다. 단일 프로그래밍과 메모리 할당 메모리 오버레이 컴퓨터의 메인 메모리보다 큰 프로그램을 실행하도록 만드는 방법 적당한 크기로 잘라서 메모리에 가져온다. module 단위로 나눈다. 프로그램의 일부만 올라와서 실행된다. 스왑 module 단위로 나누어졌을 때 사용하지 않는 module은 어디에 보관될까? 저장장치의 swap area에 보관된다. ( 공간을 마련함 ) swap in : 스왑 영역에서 메모리로 데이터를 가져옴 swap out : 메모리에서 스왑 영역으로 데이터를 내보냄 이는 메모리 관리자가 관리한다. 이때 사용자는 스왑 영역과 메모리 영역의 크기를 합쳐서 인식하게 된다. 사진에서 사용자는 5GB 프로그램을 돌리는 것으로 인식한다. 다중 프로그래밍과 메모리 지금까지는 한 프로세스만 실행되는 상황을 다루었다. 지금부터는 여러 프로세스들이 실행될 때 메모리 관리를 살펴보겠다. 메모리 분할 방식 메모리 배치 정책에 해당된다. 여러 프로세스를 메모리에 어떻게 배치할 것인가? variable-size partitioning : 가변 분할 방식 fixed-size partitioning : 고정 분할 방식 variable-size partitioning 프로세스의 크기에 맞게 메모리가 분할 된다. 즉 메모리의 영역 크기가 모두 다르다. 한 프로세스가 연속된 공간에 배치된다. contiguous memory allocation 장점 프로세스를 한 덩어리로 처리해서 연속적인 공간에 배치 가능 단점 메모리 관리가 복잡하다. fixed-size partitioning 프로세스의 크기 상관없이 메모리가 같은 크기로 분할 된다. 비연속 메모리 할당이라 부른다. noncontiguous memory allocation 장점 메모리 관리가 편하다. 단점 작은 프로세스가 올라오면 메모리 낭비가 발생한다. 혹은 잘려서 Variable-size partitioning 외부 단편화 만약 B와 D가 종료되고 E라는 프로그램이 메모리에 올라오는 상황을 생각해보자 빈 공간보다 큰 공간을 필요로 하는 E는 올라가지 못한다. 결국 E는 공간을 받을 수 있을 때까지 기다린다 ( 아사 ) 결국 작은 빈 공간이 생기게 된다. 이 현상을 Fragmentation(단편화)이라 부른다. 빈 공간을 external fragmentation이라 부른다. hole 프로세스 밖에서 빈 공간(조각)이 발생하기 때문이다. 이를 해결하기 위해 memory placement strategy : 메모리 배치 방식 조각이 발생하지 않도록 배치 defragmentation : 조각 모음 조각을 모아서 크게 만듬 메모리 배치 방식 대표적인 방법은 다음과 같다. (버디 시스템도 있다.) 최초 배치 적재 가능한 공간을 순서대로 탐색하다가 첫 번째 공간에 넣음 빈 공간 전체 탐색이 필요 없다. 다만 단편화가 잘 발생한다. 최적 배치 빈 공간을 모두 확인하고 가장 작은 공간에 배치한다. 아주 작은 조각이 남게 된다. 최악 배치 빈 공간을 모두 확인하고 가장 큰 공간에 배치한다. 남은 조각도 커서 재활용이 가능하다. 다만 시간이 지나면 작은 조각이 남는다. 조각 모음 아무리 배치를 잘해도 단편화 현상이 발생한다. 사용하지 못하는 작은 조각들을 모아 쓸모 있게 만들 필요가 있다. 단계 프로세스들 중단 적당한 위치로 차곡차곡 옮긴다. ( 상대 주소 값 ) 프로세스 다시 시작 많은 시간이 걸린다. Fixed-size partitioning 가상 메모리에서는 고정 분할 방식을 paging이라 부른다. 메모리를 같은 크기로 나누어 관리는 쉽지만 프로세스가 나눠 저장된다. 내부 단편화 기본적으로 가변 분할 방식보다는 고정 분할 방식을 기본으로 사용한다. 이는 관리가 수월하기 때문이다. 프로그램을 일정 단위로 나누기 때문에 외부 단편화는 발생하지 않는다. 일정 단위를 페이지라 부른다. ( 가상 메모리 기준 ) 하지만 단위보다 작은 공간을 필요로 하면 내부 단편화가 발생한다. internal fragmentation 이를 해결하는 방법은 없다. 조각 모음이나 남는 공간을 다른 프로세스에게 넘길 수 없다. 유일한 해결책은 단위의 크기를 조절하는 것이다.","headline":"Physical memory management","mainEntityOfPage":{"@type":"WebPage","@id":"https://highcloud100.github.io/posts/memory/"},"url":"https://highcloud100.github.io/posts/memory/"}</script><title>Physical memory management | highcloud100</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="highcloud100"><meta name="application-name" content="highcloud100"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://avatars.githubusercontent.com/u/80192345?v=4" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">highcloud100</a></div><div class="site-subtitle font-italic">One of the comforting things about old memories is their tendency to take on a rosy glow.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/highcloud100" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/highcloud100" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['highcloud100','inha.edu'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Physical memory management</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Physical memory management</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1658237400" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 19, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> baekbumsung </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2075 words"> <em>11 min</em> read</span></div></div></div><div class="post-content"><h1 id="메모리-관리의-개요">메모리 관리의 개요</h1><hr /><h2 id="시작"><span class="mr-2">시작</span><a href="#시작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>이전에는 하나의 프로그램만 실행시켜서 메모리 관리에 어려움이 크지 않았다.<li>현재 시분할 시스템에서는 많은 프로세스들이 메모리에 올라와 실행된다. 이를 효휼적으로 관리할 방법이 필요하다.</ul><h2 id="mmu"><span class="mr-2">MMU</span><a href="#mmu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>memory manage unit<li>하드웨어이다.<li>간단히 정리한다.</ul><h3 id="역할"><span class="mr-2">역할</span><a href="#역할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><p>가져오기</p><ul><li>프로세스와 데이터를 메모리로 가져온다.<li>요청이 없어도 필요할 것 같은 데이터를 미리 가져온다.</ul><li><p>배치 작업</p><ul><li>가져온 프로세스와 데이터를 메모리에 적절히 배치한다.</ul><li><p>재배치 작업</p><ul><li>메모리가 가득 찬 상황이면 일부 프로세스를 하드로 옮기는 작업을 한다.</ul></ol><h3 id="정책"><span class="mr-2">정책</span><a href="#정책" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><p>가져오기 정책</p><ul><li>프로세스의 필요한 데이터를 언제 가져올지 결정하는 정책<li>prefetch 를 하기도 한다.</ul><li><p>배치 정책</p><ul><li>paging : 메모리를 같은 크기로 자르는 것<li>segmentation : 프로세스 크기에 맞게 자르는 것<li>이런 기술을 이용해 효율적인 메모리 관리 정책을 만든다.</ul><li><p>재배치 정책</p><ul><li>replacement algorithm : 무슨 프로세스를 내보낼지 정한다.</ul></ol><h1 id="메모리-주소">메모리 주소</h1><hr /><h2 id="bit--64bit-cpu"><span class="mr-2">32bit / 64bit cpu</span><a href="#bit--64bit-cpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>메모리는 1byte마다 주소를 붙여 사용한다.</p><li><p>이때 MAR(메모리 주소 레지스터)를 이용한다.</p><ul><li>32bit는 MAR의 크기가 32비트이다.<li>64bit는 64비트</ul><li><p>여기서 cpu가 관리할 수 있는 메모리 공간의 사이즈를 알 수 있다.</p><ul><li>32bit : 2^32 byte = 4GB 정도<li>64bit : 2^64 byte = 겁내 많음</ul></ul><blockquote><p>즉 32bit에 16GB RAM을 박는 것은 …</p></blockquote><ul><li>메모리 주소는 다음과 같이 나눌 수 있다.<ul><li>Physical address space : 하드웨어 관점<li>logical address space : 사용자 입장</ul></ul><h2 id="절대-주소와-상대-주소"><span class="mr-2">절대 주소와 상대 주소</span><a href="#절대-주소와-상대-주소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="메모리-영역"><span class="mr-2">메모리 영역</span><a href="#메모리-영역" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/80192345/179690889-f78e2aa8-1139-45b1-81bf-b921fcbaec2a.png" alt="" width="400" data-proofer-ignore></p><ul><li><p>기본적으로 메모리는 운영체제 영역과 사용자 영역으로 나뉜다.</p><li><p>이때 사용자 영역이 운영체제 영역을 침범하지 못하도록</p><ul><li>cpu의 경계 레지스터 값을 이용해 검사하고 막는다.</ul><li><p>문제점은 운영체제의 크기가 변한다면 사용자 프로그램의 주소가 변해야 한다.</p><ul><li>즉 프로그램을 짤 때는 360번지부터 400번지를 사용해서 프로그래밍하면, 후에 os가 바뀌면 문제가 발생한다.<li>이렇게 직접 물리주소를 이용하는 것은 문제가 많다.</ul></ul><h3 id="절대-주소와-상대-주소-1"><span class="mr-2">절대 주소와 상대 주소</span><a href="#절대-주소와-상대-주소-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>메모리 관리자 입장에서는 실제 메모리의 주소를 사용한다.</p><ul><li>절대 주소는 실제 물리 주소를 가르킨다.</ul><li><p>하지만 사용자 프로세스 입장에서는 0번부터 생각한다.</p><ul><li>즉 운영체제와 mmu가 알아서 관리한다.<ul><li>이때 재배치 레지스터를 이용한다.</ul><li>이를 논리 주소 공간이라 부른다.</ul></ul><h1 id="단일-프로그래밍과-메모리-할당">단일 프로그래밍과 메모리 할당</h1><hr /><h2 id="메모리-오버레이"><span class="mr-2">메모리 오버레이</span><a href="#메모리-오버레이" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>컴퓨터의 메인 메모리보다 큰 프로그램을 실행하도록 만드는 방법<li>적당한 크기로 잘라서 메모리에 가져온다.<ul><li>module 단위로 나눈다.</ul><li>프로그램의 일부만 올라와서 실행된다.</ul><h2 id="스왑"><span class="mr-2">스왑</span><a href="#스왑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li><p>module 단위로 나누어졌을 때 사용하지 않는 module은 어디에 보관될까?</p><li><p>저장장치의 swap area에 보관된다. ( 공간을 마련함 )</p><ul><li>swap in : 스왑 영역에서 메모리로 데이터를 가져옴<li>swap out : 메모리에서 스왑 영역으로 데이터를 내보냄</ul><li><p>이는 메모리 관리자가 관리한다.</p><li><p>이때 사용자는 스왑 영역과 메모리 영역의 크기를 합쳐서 인식하게 된다.</p></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/179699401-51ebf063-463a-4350-ada8-cbbd2dfe5f67.png" alt="" width="500" data-proofer-ignore></p><ul><li>사진에서 사용자는 5GB 프로그램을 돌리는 것으로 인식한다.</ul><h1 id="다중-프로그래밍과-메모리">다중 프로그래밍과 메모리</h1><hr /><ul><li>지금까지는 한 프로세스만 실행되는 상황을 다루었다.<li>지금부터는 여러 프로세스들이 실행될 때 메모리 관리를 살펴보겠다.</ul><h2 id="메모리-분할-방식"><span class="mr-2">메모리 분할 방식</span><a href="#메모리-분할-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>메모리 배치 정책에 해당된다.<li>여러 프로세스를 메모리에 어떻게 배치할 것인가?<ul><li>variable-size partitioning : 가변 분할 방식<li>fixed-size partitioning : 고정 분할 방식</ul></ul><h3 id="variable-size-partitioning"><span class="mr-2">variable-size partitioning</span><a href="#variable-size-partitioning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>프로세스의 크기에 맞게 메모리가 분할 된다.</p><ul><li>즉 메모리의 영역 크기가 모두 다르다.</ul><li><p>한 프로세스가 연속된 공간에 배치된다.</p><ul><li>contiguous memory allocation</ul><li><p>장점</p><ul><li>프로세스를 한 덩어리로 처리해서 연속적인 공간에 배치 가능</ul><li><p>단점</p><ul><li>메모리 관리가 복잡하다.</ul></ul><h3 id="fixed-size-partitioning"><span class="mr-2">fixed-size partitioning</span><a href="#fixed-size-partitioning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>프로세스의 크기 상관없이 메모리가 같은 크기로 분할 된다.</p><li><p>비연속 메모리 할당이라 부른다.</p><ul><li>noncontiguous memory allocation</ul><li><p>장점</p><ul><li>메모리 관리가 편하다.</ul><li><p>단점</p><ul><li>작은 프로세스가 올라오면 메모리 낭비가 발생한다.<ul><li>혹은 잘려서</ul></ul></ul><h2 id="variable-size-partitioning-1"><span class="mr-2">Variable-size partitioning</span><a href="#variable-size-partitioning-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><h3 id="외부-단편화"><span class="mr-2">외부 단편화</span><a href="#외부-단편화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="https://user-images.githubusercontent.com/80192345/179747854-1d4f3818-f09f-4baa-b326-d3970c08f506.png" alt="" data-proofer-ignore></p><ul><li>만약 B와 D가 종료되고 E라는 프로그램이 메모리에 올라오는 상황을 생각해보자<li>빈 공간보다 큰 공간을 필요로 하는 E는 올라가지 못한다.<ul><li>결국 E는 공간을 받을 수 있을 때까지 기다린다 ( 아사 )</ul><li>결국 작은 빈 공간이 생기게 된다.<ul><li>이 현상을 Fragmentation(단편화)이라 부른다.<li>빈 공간을 external fragmentation이라 부른다.<ul><li>hole</ul></ul></ul><blockquote><p>프로세스 밖에서 빈 공간(조각)이 발생하기 때문이다.</p></blockquote><ul><li>이를 해결하기 위해<ul><li>memory placement strategy : 메모리 배치 방식<ul><li>조각이 발생하지 않도록 배치</ul><li>defragmentation : 조각 모음<ul><li>조각을 모아서 크게 만듬</ul></ul></ul><h3 id="메모리-배치-방식"><span class="mr-2">메모리 배치 방식</span><a href="#메모리-배치-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><hr /><ul><li>대표적인 방법은 다음과 같다. (버디 시스템도 있다.)</ul><ol><li>최초 배치<ul><li>적재 가능한 공간을 순서대로 탐색하다가 첫 번째 공간에 넣음<li>빈 공간 전체 탐색이 필요 없다.<li>다만 단편화가 잘 발생한다.</ul><li>최적 배치<ul><li>빈 공간을 모두 확인하고 가장 작은 공간에 배치한다.<li>아주 작은 조각이 남게 된다.</ul><li>최악 배치<ul><li>빈 공간을 모두 확인하고 가장 큰 공간에 배치한다.<li>남은 조각도 커서 재활용이 가능하다.<li>다만 시간이 지나면 작은 조각이 남는다.</ul></ol><p><img data-src="https://user-images.githubusercontent.com/80192345/179751068-8ba2f15e-0ec7-4ae1-876b-46bd9024794e.png" alt="" width="500" data-proofer-ignore></p><h3 id="조각-모음"><span class="mr-2">조각 모음</span><a href="#조각-모음" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>아무리 배치를 잘해도 단편화 현상이 발생한다.</p><li><p>사용하지 못하는 작은 조각들을 모아 쓸모 있게 만들 필요가 있다.</p><li><p>단계</p><ol><li>프로세스들 중단<li>적당한 위치로 차곡차곡 옮긴다. ( 상대 주소 값 )<li>프로세스 다시 시작</ol><li><p>많은 시간이 걸린다.</p></ul><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/FragmentationDefragmentation.gif/330px-FragmentationDefragmentation.gif" alt="" data-proofer-ignore></p><h2 id="fixed-size-partitioning-1"><span class="mr-2">Fixed-size partitioning</span><a href="#fixed-size-partitioning-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><hr /><ul><li>가상 메모리에서는 고정 분할 방식을 paging이라 부른다.<li>메모리를 같은 크기로 나누어 관리는 쉽지만 프로세스가 나눠 저장된다.</ul><h3 id="내부-단편화"><span class="mr-2">내부 단편화</span><a href="#내부-단편화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>기본적으로 가변 분할 방식보다는 고정 분할 방식을 기본으로 사용한다.</p><ul><li>이는 관리가 수월하기 때문이다.</ul><li><p>프로그램을 일정 단위로 나누기 때문에 외부 단편화는 발생하지 않는다.</p><ul><li>일정 단위를 페이지라 부른다. ( 가상 메모리 기준 )</ul><li><p>하지만 단위보다 작은 공간을 필요로 하면 내부 단편화가 발생한다.</p><ul><li>internal fragmentation</ul><li><p>이를 해결하는 방법은 없다.</p><ul><li>조각 모음이나 남는 공간을 다른 프로세스에게 넘길 수 없다.</ul><li><p>유일한 해결책은 단위의 크기를 조절하는 것이다.</p></ul><p><img data-src="https://user-images.githubusercontent.com/80192345/179763596-afe83edf-58bb-4174-8e38-e37d1b127651.png" alt="" width="500" data-proofer-ignore></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/cs/'>CS</a>, <a href='/categories/os/'>OS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/os/" class="post-tag no-text-decoration" >os</a> <a href="/tags/cs/" class="post-tag no-text-decoration" >cs</a> <a href="/tags/summer/" class="post-tag no-text-decoration" >summer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Physical+memory+management+-+highcloud100&url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fmemory%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Physical+memory+management+-+highcloud100&u=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fmemory%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fhighcloud100.github.io%2Fposts%2Fmemory%2F&text=Physical+memory+management+-+highcloud100" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div><script src="https://utteranc.es/client.js" repo="highcloud100/blog-utterances" issue-term="pathname" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/xv6%EB%B0%B1%EC%97%85/">xv6 백업</a><li><a href="/posts/gpuServerSetting/">gpu 서버 세팅</a><li><a href="/posts/winter/">2023 Winter Vacation</a><li><a href="/posts/%EB%85%B8%ED%8A%B8%EB%B6%81-%EC%84%B8%ED%8C%85/">노트북 세팅</a><li><a href="/posts/plan240508/">추후 계획과 현 상황?</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/start/"><div class="card-body"> <em class="small" data-ts="1656982800" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>운영체제 공부 정리</h3><div class="text-muted small"><p> 운영체제 공부 정리 2학년 여름 방학 운영체제에 대해 공부하려 한다. 7월 20일까지 공부 계획 중… 공부 자료 / 출처 OS쉽게 배우는 운영체제 조성호널널한 개발자 - 운영체제 강의Kernel of linux 고건 교수님실습과 그림으로 배우는 리눅스 구조</p></div></div></a></div><div class="card"> <a href="/posts/intro/"><div class="card-body"> <em class="small" data-ts="1656988740" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>intro of OS</h3><div class="text-muted small"><p> OS 운영체제는 사용자와 컴퓨터 사이에서 하드웨어 사이에서 작동하는 시스템이다. 운영체제의 목표는 다음과 같다. OS자원관리자원 보호하드웨어 인터페이스사용자 인터페이스효휼성안정성확장성편리성 Performance Throughput — jobs/sec Utilization — % of time busy Response time — sec / j...</p></div></div></a></div><div class="card"> <a href="/posts/systemcall/"><div class="card-body"> <em class="small" data-ts="1656999000" data-df="ll" > Jul 5, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>System Call</h3><div class="text-muted small"><p> SystemCall system call은 커널에게 I/O 작업을 요청하는 것이다. 하드웨어의 mode bit 를 사용하여 커널모드와 유저모드로 나눈다. cpu의 mode bit 가 0이면 kernel mode 이며, cpu는 어떤 메모리의 영역이든 접근할 수 있다. mode bit이 1이면 user mode로 cpu는 파일에 영향을 주는 명령...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Normalization/" class="btn btn-outline-primary" prompt="Older"><p>Normalization</p></a> <a href="/posts/cnn1/" class="btn btn-outline-primary" prompt="Newer"><p>CNN-1</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/highcloud100">baekbumsung</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs/">cs</a> <a class="post-tag" href="/tags/summer/">summer</a> <a class="post-tag" href="/tags/ai/">AI</a> <a class="post-tag" href="/tags/ml/">ML</a> <a class="post-tag" href="/tags/os/">os</a> <a class="post-tag" href="/tags/network/">network</a> <a class="post-tag" href="/tags/distributed-systems/">Distributed_Systems</a> <a class="post-tag" href="/tags/tcp/">tcp</a> <a class="post-tag" href="/tags/%EC%8B%A4%EC%8A%B5%EA%B3%BC-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B5%AC%EC%A1%B0/">실습과 그림으로 배우는 리눅스 구조</a> <a class="post-tag" href="/tags/life/">life</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-233565867-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-233565867-1'); </script>
