---
title: Process synchronization
author: highcloud
date: 2022-07-17 00:25:00 +0900
categories: [CS, OS]
tags: [os, cs, summer]
render_with_liquid: false
---

<h1 id="inter-process-communication">Inter-Process Communication</h1>
<hr>
<ul>
<li>프로세스 간 통신이다.
<ul>
<li>즉 프로세스들이 데이터를 주고 받는 행위와 경로, 방법을 논한다.</li>
</ul>
</li>
</ul>
<h2 id="ipc의-종류">IPC의 종류</h2>
<hr>
<ol>
<li>
<p>프로세스 내부 데이터 통신</p>
<ul>
<li>하나의 프로세스 내에 2개 이상 쓰레드가 존재할 때</li>
<li>전역변수나 파일을 이용</li>
</ul>
</li>
<li>
<p>프로세스 간 데이터 통신</p>
<ul>
<li>공용 파일 혹은 OS의 파이프를 이용한다.</li>
</ul>
</li>
<li>
<p>네트워크를 이용한 데이터 통신</p>
<ul>
<li>여러 컴퓨터가 네트워크로 연결된 경우</li>
<li>소켓을 이용한다.</li>
</ul>
</li>
</ol>
<blockquote>
<p>네트워킹 : 소켓을 이용한 통신<br>
한 컴퓨터 내 에서는 소켓보다는 다른 방법으로 통신한다.</p>
</blockquote>
<h2 id="ipc의-분류">IPC의 분류</h2>
<hr>
<h3 id="통신-방향에-따른-분류">통신 방향에 따른 분류</h3>
<hr>
<ol>
<li>양방향 통신
<ul>
<li>양쪽으로 데이터를 동시에 전송 가능한 구조</li>
<li>소켓 방식이 있다.</li>
</ul>
</li>
<li>반양방향 통신
<ul>
<li>양쪽으로 전송 가능하나 동시 전송이 불가능하다.</li>
<li>특정 시점에 한 방향으로만 전송 가능하다.</li>
</ul>
</li>
<li>단방향 통신
<ul>
<li>한쪽으로만 전송 가능한 구조이다.</li>
<li>프로세스 간 통신에서는 전역 변수, 파이프가 해당한다.</li>
</ul>
</li>
</ol>
<blockquote>
<p>전역변수는 양쪽에서 데이터를 지정할 때  하나만 적용된다.</p>
</blockquote>
<h3 id="통신-구현-방식에-따른-분류">통신 구현 방식에 따른 분류</h3>
<hr>
<h4 id="busy-waiting">busy waiting</h4>
<hr>
<ul>
<li>받는 쪽에서 보낸 데이터가 있는 지 계속 확인하는 상태를 말한다.
<ul>
<li>무한 반복으로 수시로 변수 값을 확인한다.</li>
<li>오버헤드가 크다.</li>
</ul>
</li>
</ul>
<h4 id="synchronization">synchronization</h4>
<hr>
<ul>
<li>위 문제를 위해 데이터가 도착했음을 알려주는 동기화가 필요하다.</li>
<li>이는 대기가 있는 지에 따라 동기화 여부를 나눈다.</li>
</ul>
<ol>
<li>대기가 있는 통신 ( 동기화 )
<ul>
<li>파이프, 소켓</li>
</ul>
</li>
<li>대기가 없는 통신 ( 비 동기화 )
<ul>
<li>전역 변수, 파일</li>
</ul>
</li>
</ol>
<h2 id="ipc의-종류-1">IPC의 종류</h2>
<hr>
<ul>
<li>기본적으로 쓰기, 읽기로 간소화 할 수 있다.</li>
</ul>
<h3 id="전역-변수를-이용한-통신">전역 변수를 이용한 통신</h3>
<hr>
<ul>
<li>직접적인 관련이 있는 프로세스에서 사용한다.</li>
<li>전역 변수를 이용해 읽고 쓰기를 진행한다.</li>
<li>다만 받는 입장에서는 전역변수가 바뀌었는지 계속 확인해야 한다.
<ul>
<li>busy waiting 문제</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/80192345/179342528-82204555-8c5d-434f-a287-a8cf43b65266.png" alt=""></p>
<h3 id="파일을-이용한-통신">파일을 이용한 통신</h3>
<hr>
<ul>
<li>파일을 open, write, read, close 연산을 통해 사용한다.</li>
<li>부모 자식 간 통신에 많이 사용된다.</li>
<li>OS가 동기화를 지원하지 않는다.
<ul>
<li>프로세스 수준에서 wait를 이용하여 동기화를 진행한다.</li>
<li>자식을 기다림</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/80192345/179342800-3e2b50c5-bfbb-4aab-81a6-39fed3d335b3.png" alt=""></p>
<h3 id="파이프를-이용한-통신">파이프를 이용한 통신</h3>
<hr>
<ul>
<li>파이프
<ul>
<li>운영체제가 제공하는 동기화 통신</li>
<li>open, close 이용</li>
</ul>
</li>
<li>단방향 통신</li>
<li>파이프의 종류
<ul>
<li>이름 없는 파이프
<ul>
<li>부모 자식 간, 형제 사이 등 관련 있는 프로세스 간 통신</li>
</ul>
</li>
<li>이름 있는 파이프
<ul>
<li>FIFO라는 특수 파일 이용, 관련 없는 프로세스 간 통신</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/80192345/179342927-a3b1ff9b-3de2-4025-872d-ddc4e5853d8c.png" alt=""></p>
<h3 id="소켓을-이용한-통신">소켓을 이용한 통신</h3>
<hr>
<ul>
<li>소켓을 이용한 통신은 네트워크를 통해 다른 컴퓨터와 연결 가능하다.</li>
<li>동기화를 지원하며 하나의 소켓으로 양방향 통신이 가능하다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/80192345/179343283-6f272eb1-40aa-4461-b6fa-be2aa6248f2f.png" alt=""></p>
<h1 id="shared-resource--critical-section">Shared resource &amp; Critical Section</h1>
<hr>
<h2 id="shared-resource">Shared resource</h2>
<hr>
<ul>
<li>여러 프로세스들이 함께 이용하는 자원을 말한다.</li>
<li>자원은 cpu가 될 수도 있고 메모리가 될 수도 있다. ( 이외 여러가지 )</li>
</ul>
<h3 id="race-condition">Race Condition</h3>
<ul>
<li>여러 프로세스가 동시에 자원에 접근해 경쟁 하는 상태를 race condition이라 부른다.</li>
<li>이는 예상치 못한 결과를 야기한다.</li>
</ul>
<h2 id="critical-section">Critical section</h2>
<hr>
<ul>
<li>둘 이상의 프로세스(쓰레드)가 동시에 접근하면 안되는 공유 자원을 접근하는 코드의 일부를 이야기한다.</li>
<li>즉 병렬 실행 중 한 프로세스(쓰레드)만 유일하게 실행할 수 있는 코드 부분을 이야기한다.</li>
</ul>
<h2 id="해결-조건">해결 조건</h2>
<hr>
<ul>
<li>
<p>위와 같은 공유 자원을 동시에 접근하는 행위는 문제를 일으킨다.</p>
<ul>
<li><a href="https://modoocode.com/270">왜 문제가 될까?</a> 앞 뒤 글을 모두 읽고 코딩해보자.</li>
</ul>
</li>
<li>
<p>이를 해결하는 여러 방법이 나왔고, 이때의 조건이 있다.</p>
</li>
</ul>
<ol>
<li>mutual exclusion
<ul>
<li>한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어가지 못한다.</li>
</ul>
</li>
<li>bounded waiting
<ul>
<li>무한 대기가 발생하면 안된다.</li>
<li>데드락 관련 문제</li>
</ul>
</li>
<li>progress flexibility
<ul>
<li>한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.</li>
</ul>
</li>
</ol>
<h1 id="solutions">Solutions</h1>
<hr>
<ul>
<li>이 부분부터 일부는 <a href="https://www.youtube.com/watch?v=oTIp836P0-w&amp;list=PLL3t9Nt4HrfvGwOgy6UhLtS9iVKhlk4pk&amp;index=17">KUOCW 최린 교수님의 수업</a>을 따라간다.</li>
</ul>
<h2 id="hw">H/W</h2>
<hr>
<ul>
<li>
<p>하드웨어 수준에서 Mutual Exclusion을 해결하는 방법이다.</p>
</li>
<li>
<p>단순한 코드 한 줄을 실행하는 것도 여러 단계의 어셈블리 언어를 통해 작동된다. ( 위에 “왜 문제가 될까?” 글 참고 )</p>
<ul>
<li>이때 context change가 발생하면 문제가 생긴다.</li>
</ul>
</li>
<li>
<p>그래서 이에 대한 해결책으로 기계어를 묶어버리는 것이다.</p>
<ul>
<li>즉 원자성을 보장함</li>
</ul>
</li>
<li>
<p>이를 ‘‘Special Instructions’’ 라고 부른다.</p>
</li>
<li>
<p>다음과 같은 명령어가 있다.</p>
<ul>
<li>test and set</li>
<li>fetch and add</li>
<li>compare and swap</li>
<li>etc</li>
</ul>
</li>
<li>
<p>이를 이용해서 Mutual Exclusion, semaphore를 구현할 수 있다.</p>
</li>
<li>
<p>문제점</p>
<ul>
<li>busy waiting</li>
<li>dead lock</li>
</ul>
</li>
</ul>
<h3 id="compare-and-wait">Compare and wait</h3>
<hr>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>word<span class="token punctuation">,</span> <span class="token keyword">int</span> testval<span class="token punctuation">,</span> <span class="token keyword">int</span> newval<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> oldval<span class="token punctuation">;</span>
	oldval <span class="token operator">=</span> <span class="token operator">*</span>word<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>oldval <span class="token operator">==</span> testval<span class="token punctuation">)</span> <span class="token operator">*</span>word <span class="token operator">=</span> newval<span class="token punctuation">;</span>
	<span class="token keyword">return</span> oldval<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>
<p>word 값이 testval 과 같으면 newval로 교체함</p>
</li>
<li>
<p>이를 이용해 mutual exclusion을 구현해보자.</p>
</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">int</span>  n <span class="token operator">=</span> number of processes
<span class="token keyword">int</span> bolt<span class="token punctuation">;</span> <span class="token comment">//락 변수 </span>
<span class="token keyword">void</span> <span class="token function">p</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bolt<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
			<span class="token comment">/* do nothing */</span>
		<span class="token comment">// critical section</span>
		bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// remainder</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token function">p</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>하나의 프로세스에서만 while문을 통과한다.</li>
<li>이후 임계 구역을 지나고 다시 bolt를 0으로 수정한다.</li>
<li>이후 하나의 프로세스만 while문을 통과한다.</li>
</ul>
<h3 id="exchange">Exchange</h3>
<hr>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">register</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> memory<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> temp<span class="token punctuation">;</span>
	temp <span class="token operator">=</span> <span class="token operator">*</span>memory<span class="token punctuation">;</span>
	<span class="token operator">*</span>memory <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">register</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token keyword">register</span> <span class="token operator">=</span> temp
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>이를 이용해 mutual exclusion을 구현해보자.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">int</span>  n <span class="token operator">=</span> number of processes
<span class="token keyword">int</span> bolt<span class="token punctuation">;</span> <span class="token comment">//락 변수 </span>
<span class="token keyword">void</span> <span class="token function">p</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> keyi <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">do</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>keyi<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bolt<span class="token punctuation">)</span>
		<span class="token keyword">while</span><span class="token punctuation">(</span>keyi <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
		
		<span class="token comment">// critical section</span>
		bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token comment">// remainder</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	bolt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token function">p</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>하나의 프로세스에서만 while문을 통과한다.</li>
<li>이후 임계 구역을 지나고 다시 bolt를 0으로 수정한다.</li>
<li>이후 하나의 프로세스만 while문을 통과한다.</li>
</ul>
<h3 id="special-instructions">Special Instructions</h3>
<hr>
<ul>
<li>atomic instructions</li>
</ul>
<h4 id="장점">장점</h4>
<ul>
<li>멀티 프로세스에서도 share resource가 가능하다.</li>
<li>simple</li>
<li>multiple 임계 구역을 지원한다.
<ul>
<li>여러 변수 이용</li>
</ul>
</li>
</ul>
<h4 id="단점">단점</h4>
<ul>
<li>busy working</li>
<li>starvation</li>
<li>dead lock
<ul>
<li>만약 p1이 임계 구역에 들어갔을 때 interrupted 당하고 p2가 우선순위가 높아 실행되어 버림</li>
<li>p2는 mutual exclusion 때문에 loop를 돌게됨</li>
<li>그러나 p1은 낮은 우선순위로 p2를 기다리게됨</li>
</ul>
</li>
</ul>
<h2 id="semaphore">Semaphore</h2>
<hr>
<ul>
<li>뭔가 소프트웨어적 이상적인 구현 방법이 없을까?
<ul>
<li>다익스트라 등장!</li>
</ul>
</li>
<li>추상적인 세마포어 변수를 이용한 알고리즘
<ul>
<li>V operation (‘signal’)
<ul>
<li>increment the semaphore</li>
</ul>
</li>
<li>P operation (‘wait’)
<ul>
<li>decrement the semaphore</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="type-of-semaphore">type of semaphore</h3>
<ol>
<li>Binary semaphore
<ul>
<li>0, 1 (locked, unlocked)</li>
</ul>
</li>
<li>Counting semaphore
<ul>
<li>임의의 값</li>
</ul>
</li>
</ol>
<h3 id="def">def</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">struct</span> semaphore<span class="token punctuation">{</span>
	<span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// 이때 count 값은 공유 가능한 자원의 수를 나타낸다. </span>
	queueType queue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">semWait</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 남은 자원이 없음</span>
		<span class="token comment">// place this process in s.queue</span>
		<span class="token comment">// block this process</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">semSignal</span><span class="token punctuation">(</span>semaphore s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 남은 프로세스가 있음</span>
		<span class="token comment">// remove a process P from s.queue</span>
		<span class="token comment">// place process P on ready list</span>
	<span class="token punctuation">}</span>	
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>만약 프린터가 2개면 세마포어 값은 초기에 2이다.<br>
양의 값을 남은 자원<br>
음의 값을 대기 중인 프로세스라고 생각하면 편한 것 같다.</p>
</blockquote>
<h3 id="ex">Ex</h3>
<p><img src="https://user-images.githubusercontent.com/80192345/179353907-28bfbee4-2533-4704-80d4-ffc091196261.png" alt=""></p>
<h3 id="mutual-exclusion">mutual exclusion</h3>
<ul>
<li>이를 이용해 mutual exclusion을 구현해보자.</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> number of process
semaphore s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// critical section</span>
		<span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// remainder</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">P</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">P</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p><img src="https://user-images.githubusercontent.com/80192345/179354086-a0fc8552-8a4d-4a7e-a03a-147e1429e38f.png" alt=""></p>
<ul>
<li>세마포어는 하드웨어적으로 구현하기 불가능하다.
<ul>
<li>하지만 결국 구현 시 atomic instruction을 사용한다.</li>
</ul>
</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">// do nothing</span>
	s<span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// place this process in s.queue</span>
		<span class="token comment">// block this process (must also set s.flag to 0)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">compare_and_swap</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>flag<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token comment">//do nothing</span>
	s<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token comment">// remove a process p from s.queue</span>
		<span class="token comment">// place process p on ready list</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>소프트 웨어 적으로는 피터슨과 테커 알고리즘으로 구현된다.</li>
</ul>
<blockquote>
<p>데커는 하드웨어 도움이 필요 없지만 피터슨은 필요로 한다.</p>
</blockquote>
<h2 id="producerconsumer-problem">Producer/Consumer Problem</h2>
<hr>
<ul>
<li>여러 문제 중 여러 명의 producer와 한 명의 consumer를 가정해보자.</li>
<li>producer나 consumer 든 한 사람만이 특정 시간에 버퍼에 접근 가능하다.</li>
<li>빈 버퍼에서 가져오거나 가득 찼는데 채우는 문제를 고려해야 한다.</li>
</ul>
<h3 id="program">program</h3>
<pre class=" language-c"><code class="prism  language-c">semaphore n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
<span class="token comment">// n은 물건 개수, s는 critical section</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">semSignal</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">semWait</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// n이 0보다 크면 consume 가능</span>
		<span class="token function">semWait</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">semSignal</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>두 개의 세마포어를 사용한다.</li>
<li>처음에는 n이 0개 이므로 consumer는 실행이 되지 않는다.</li>
<li>이후 생산자에서 n 시그널을 보낸다.</li>
<li>consumer는 1차 벽을 통과하지만 만약 producer가 critical section에 있으면 wait한다.</li>
<li>이후 take한다.</li>
</ul>
<h3 id="quiz">Quiz</h3>
<ol>
<li>만약 producer에서 semSignal의 s와 n의 순서를 바꾸면?
<ul>
<li>상관 없다.</li>
</ul>
</li>
<li>만약 producer에서 semWait의 n과 s의 순서를 바꾸면?
<ul>
<li>데드락이 걸린다.</li>
<li>consumer가 먼저 임계 구역에 들어감</li>
<li>하지만 n으로 인해 waiting</li>
<li>그러나 producer또한 s로 인해 waiting</li>
</ul>
</li>
</ol>
<h2 id="monitor">Monitor</h2>
<hr>
<h3 id="semaphore의-단점">semaphore의 단점</h3>
<ul>
<li>세마포어로는 프로그램을 개발하기 어렵다.
<ul>
<li>프로그래머의 실수로 임계 구역이 보호 받지 못할 수도 있다.</li>
</ul>
</li>
<li>전체 프로그램을 파악하기 어렵다.</li>
</ul>
<h3 id="monitor-1">monitor</h3>
<ul>
<li>
<p>프로그래밍 언어에서 제공하는 기능이다.</p>
<ul>
<li>semaphore 대체 가능하다.</li>
<li>사용자는 걱정을 안해도 된다.</li>
</ul>
</li>
<li>
<p>모니터는 기본적으로 하나 혹은 이상의 procedures로 되어있다.</p>
<ul>
<li>초기화 코드와 지역 변수도 있다.</li>
</ul>
</li>
<li>
<p>한번에 하나의 프로세스만 모니터 안에서 실행 가능하다.</p>
<ul>
<li>mutual exclusion</li>
</ul>
</li>
<li>
<p>모니터 안에 정의된 변수는 모니터 안에 지정된 procedures로만 접근 가능하다.</p>
</li>
</ul>
<h3 id="condition-variable">condition variable</h3>
<p>-모니터는 동기화를 위해 상태 변수를 사용한다.</p>
<ul>
<li>다음과 같은 함수로 계산된다.
<ul>
<li>cwait( )
<ul>
<li>프로세스를 대기 시킴 ( 특정 컨디션까지 )</li>
</ul>
</li>
<li>csignal( )
<ul>
<li>blocked 된 프로세스를 깨움 ( 같은 컨디션에서 )</li>
<li>만약 대기 중인 프로세스가 없으면 아무것도 안 함</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/80192345/179358315-50a0af51-0e41-436a-bc9a-540d5e07404d.png" alt="" width="400"></p>
<ul>
<li>
<p>코드를 보면 이해하기 좋다.</p>
</li>
<li>
<p>모니터의 코드</p>
<ul>
<li>모니터 안의 함수를 사용하여 안에서 작업한다.</li>
<li>이 코드 실행은 하나의 프로세스만 가능함을 보장한다.
<ul>
<li>즉 wait가 걸리면 위 그림처럼 대기 타야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class=" language-c"><code class="prism  language-c">monitor boundedbuffer<span class="token punctuation">;</span> <span class="token comment">// 모니터 코드</span>
<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// space for N items</span>
<span class="token keyword">int</span> nextin<span class="token punctuation">,</span> nextout<span class="token punctuation">;</span> <span class="token comment">// buffer pointers</span>
<span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment">// number of items in buffer</span>
cond notfull<span class="token punctuation">,</span> notempty<span class="token punctuation">;</span> <span class="token comment">// conditional var for synch</span>

<span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span> <span class="token function">cwait</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// buffer is full?</span>
	<span class="token comment">// full -&gt; notfull일때까지 wait</span>
	
	buffer<span class="token punctuation">[</span>nextin<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
	nextin <span class="token operator">=</span> <span class="token punctuation">(</span>nextin<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">;</span>
	count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token comment">// one more item in buffer</span>
	<span class="token function">csignal</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//resume any waiting consumer</span>
	<span class="token comment">//누군가 notempty를 기다리면 wake up 시킴</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token keyword">char</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">cwait</span><span class="token punctuation">(</span>notempty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// buffer is empty?</span>
	<span class="token comment">//count==0 이면 notempty  까지 wait</span>
	x <span class="token operator">=</span> buffer<span class="token punctuation">[</span>nextout<span class="token punctuation">]</span><span class="token punctuation">;</span>
	nextout <span class="token operator">=</span>  <span class="token punctuation">(</span>nextout<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>N<span class="token punctuation">;</span>
	count<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token function">csignal</span><span class="token punctuation">(</span>notfull<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// resume any waiting producer</span>
	nextin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> nextout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// buffer initially empty</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>producer와 consumer의 코드</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> x<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">produce</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">append</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">char</span> x<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">take</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">consume</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="message-passing">Message passing</h2>
<hr>
<ul>
<li>
<p>가장 일반적이고 쉽다!</p>
<ul>
<li>mutual exclusion</li>
<li>synchronization</li>
<li>communication</li>
<li>모두 가능</li>
</ul>
</li>
<li>
<p>shared mem, distributed mem 모두 가능</p>
</li>
</ul>
<h3 id="function">Function</h3>
<ul>
<li>send (dest, msg)</li>
<li>receive (dest, msg)</li>
</ul>
<h3 id="communication">Communication</h3>
<ul>
<li>둘 간에 동기화가 된다는 것을 의미함</li>
<li>리시버는 다른 프로세스가 보내기 전까지 받지 못한다.</li>
</ul>
<h3 id="blocking-nonblocking-sender-receiver">Blocking, nonblocking sender, receiver</h3>
<ul>
<li>
<p>blocking</p>
<ul>
<li>sender
<ul>
<li>받을 때까지 기다림</li>
</ul>
</li>
<li>receiver
<ul>
<li>보낼 때까지 기다림</li>
</ul>
</li>
</ul>
</li>
<li>
<p>non</p>
<ul>
<li>sender
<ul>
<li>그냥 보내버림</li>
</ul>
</li>
<li>receiver
<ul>
<li>그냥 포기해버림</li>
</ul>
</li>
</ul>
</li>
<li>
<p>보통 non send, blocking receive 사용한다.</p>
</li>
</ul>
<h3 id="addressing">Addressing</h3>
<ul>
<li>direct
<ul>
<li>명시해서 보내거나 받음</li>
<li>아무한테나 받아서 리턴함</li>
</ul>
</li>
<li>indirect
<ul>
<li>메일 박스에 보내버림 ( 홀드 )</li>
</ul>
</li>
</ul>
<h3 id="mutual-exclusion-1">Mutual exclusion</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> number of processes<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	message msg<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>ture<span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">receive</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 메시지는 하나만 받을 수 있음</span>
		<span class="token comment">// critical section</span>
		<span class="token function">send</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// remainder</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	create mailbox box<span class="token punctuation">;</span>
	<span class="token function">send</span><span class="token punctuation">(</span>box<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">p</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="producer-consumer-with-msg">Producer Consumer with msg</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> cap <span class="token operator">=</span> buffering cap<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> null <span class="token operator">=</span> empty msg<span class="token punctuation">;</span>
<span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	message pmsg<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">receive</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> pmsg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 못 받으면 blocking</span>
		pmsg <span class="token operator">=</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">send</span><span class="token punctuation">(</span>mayconsume<span class="token punctuation">,</span> pmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	message cmsg<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function">receive</span><span class="token punctuation">(</span>mayconsume<span class="token punctuation">,</span> cmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">consume</span><span class="token punctuation">(</span>cmsg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">send</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">create_mailbox</span> <span class="token punctuation">(</span>mayproduce<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">create_mailbox</span> <span class="token punctuation">(</span>mayconsume<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cap<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">send</span><span class="token punctuation">(</span>mayproduce<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">parbegin</span><span class="token punctuation">(</span>producer<span class="token punctuation">,</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>

